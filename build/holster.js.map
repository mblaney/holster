{
  "version": 3,
  "sources": ["../src/utils.js", "../src/dup.js", "../src/get.js", "../src/array.js", "../src/buffer.js", "../src/sea-utils.js", "../src/sea.js", "../src/ham.js", "../src/radix.js", "../src/radisk.js", "../src/store.js", "../src/wire.js", "../src/user.js", "../src/holster.js"],
  "sourcesContent": ["export const num = {\n  is: n => {\n    if (n instanceof Array) return false\n\n    if (typeof n === \"number\") return !isNaN(n)\n\n    if (typeof n === \"string\") {\n      const parsed = parseFloat(n)\n      return !isNaN(parsed) && isFinite(parsed)\n    }\n\n    return false\n  },\n}\n\nexport const obj = {\n  is: o => {\n    if (!o || typeof o !== \"object\") return false\n\n    const toString = Object.prototype.toString.call(o)\n    const match = toString.match(/^\\[object (\\w+)\\]$/)\n    return o.constructor === Object || (match && match[1] === \"Object\")\n  },\n  map: (list, cb, o) => {\n    var keys = Object.keys(list)\n    for (let i = 0; i < keys.length; i++) {\n      let result = cb(list[keys[i]], keys[i], o)\n      if (typeof result !== \"undefined\") return result\n    }\n  },\n  put: (o, key, value) => {\n    if (!o) o = {}\n    o[key] = value\n    return o\n  },\n  del: (o, key) => {\n    if (!o) return\n\n    o[key] = null\n    delete o[key]\n    return o\n  },\n}\n\nconst map_soul = (soul, key, o) => {\n  // If id is already defined AND we're still looping through the object,\n  // then it is considered invalid.\n  if (o.id) {\n    o.id = false\n    return\n  }\n\n  if (key === \"#\" && typeof soul === \"string\") {\n    o.id = soul\n    return\n  }\n\n  // If there exists anything else on the object that isn't the soul,\n  // then it is considered invalid.\n  o.id = false\n}\n\n// Check if an object is a soul relation, ie {'#': 'UUID'}\nexport const rel = {\n  is: value => {\n    if (value && value[\"#\"] && !value._ && obj.is(value)) {\n      let o = {}\n      obj.map(value, map_soul, o)\n      if (o.id) return o.id\n    }\n\n    return false\n  },\n  // Convert a soul into a relation and return it.\n  ify: soul => obj.put({}, \"#\", soul),\n}\n\nexport const userSignature = \"_holster_user_signature\"\nexport const userPublicKey = \"_holster_user_public_key\"\n\n// graph converts objects to graph format with updated states,\n// with optional meta data to verify signed data.\nexport const graph = (soul, data, sig, pub) => {\n  const timestamp = Date.now()\n  const g = {[soul]: {_: {\"#\": soul, \">\": {}}}}\n\n  for (const [key, value] of Object.entries(data)) {\n    if (key !== \"_\" && key !== userPublicKey && key !== userSignature) {\n      g[soul][key] = value\n      g[soul]._[\">\"][key] = timestamp\n    }\n  }\n  // Store per-property signatures in node._[\"s\"]\n  // sig is an object with per-property signatures\n  if (sig && pub) {\n    g[soul]._[\"s\"] = {}\n    for (const [key, signature] of Object.entries(sig)) {\n      g[soul]._[\"s\"][key] = signature\n    }\n    g[soul][userPublicKey] = pub\n    g[soul]._[\">\"][userPublicKey] = timestamp\n  }\n  return g\n}\n\nexport const match = (lex, key) => {\n  // Null is used to match listeners on souls, which don't provide a key.\n  if (typeof key === \"undefined\") return lex === null\n\n  if (typeof lex === \"undefined\") return true\n\n  if (typeof lex === \"string\") return lex === key\n\n  if (!obj.is(lex) || !key) return false\n\n  const prefix = lex[\"*\"]\n  if (prefix) return key.slice(0, prefix.length) === prefix\n\n  const gt = lex[\">\"]\n  const lt = lex[\"<\"]\n  if (gt && lt) return key >= gt && key <= lt\n\n  if (gt) return key >= gt\n\n  if (lt) return key <= lt\n\n  return false\n}\n\nexport const text = {\n  random: length => {\n    var s = \"\"\n    const c = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n    if (!length) length = 24\n    for (let i = 0; i < length; i++) {\n      s += c.charAt(Math.floor(Math.random() * c.length))\n    }\n    return s\n  },\n}\n", "const Dup = maxAge => {\n  // Allow maxAge to be passed in as tests wait on the setTimeout.\n  if (!maxAge) maxAge = 9000\n  const dup = {store: {}}\n  dup.check = id => (dup.store[id] ? dup.track(id) : false)\n  dup.track = id => {\n    // Keep the liveliness of the message up while it is being received.\n    dup.store[id] = Date.now()\n    if (!dup.expiry) {\n      dup.expiry = setTimeout(() => {\n        if (dup.expiry) return\n\n        const now = Date.now()\n        Object.keys(dup.store).forEach(id => {\n          if (now - dup.store[id] > maxAge) delete dup.store[id]\n        })\n        dup.expiry = null\n      }, maxAge)\n    }\n    return id\n  }\n  return dup\n}\n\nexport default Dup\n", "import {match} from \"./utils.js\"\n\nconst Get = (lex, graph) => {\n  if (!lex || typeof lex !== \"object\") {\n    throw new TypeError(\"lex must be an object\")\n  }\n  if (!graph || typeof graph !== \"object\") {\n    throw new TypeError(\"graph must be an object\")\n  }\n\n  const soul = lex[\"#\"]\n  if (!soul || typeof soul !== \"string\") {\n    throw new TypeError(\"soul must be a string\")\n  }\n\n  if (!graph[soul]) return\n\n  const node = {_: {\"#\": soul, \">\": {}}}\n  let signatures = {}\n\n  if (typeof lex[\".\"] === \"string\") {\n    const key = lex[\".\"]\n    if (typeof graph[soul][key] === \"undefined\") return\n\n    node[key] = graph[soul][key]\n    node._[\">\"][key] = graph[soul]._[\">\"][key]\n    if (graph[soul]._[\"s\"] && graph[soul]._[\"s\"][key]) {\n      signatures[key] = graph[soul]._[\"s\"][key]\n    }\n  } else {\n    for (const key of Object.keys(graph[soul])) {\n      if (match(lex[\".\"], key)) {\n        node[key] = graph[soul][key]\n        node._[\">\"][key] = graph[soul]._[\">\"][key]\n        if (graph[soul]._[\"s\"] && graph[soul]._[\"s\"][key]) {\n          signatures[key] = graph[soul]._[\"s\"][key]\n        }\n      }\n    }\n  }\n  if (Object.keys(signatures).length > 0) {\n    node._[\"s\"] = signatures\n  }\n  return {[soul]: node}\n}\n\nexport default Get\n", "if (typeof btoa === \"undefined\") {\n  globalThis.btoa = data => Buffer.from(data, \"binary\").toString(\"base64\")\n  globalThis.atob = data => Buffer.from(data, \"base64\").toString(\"binary\")\n}\n\n// This is Array extended to have .toString([\"utf8\"|\"hex\"|\"base64\"])\nfunction SeaArray() {}\nObject.assign(SeaArray, {from: Array.from})\nSeaArray.prototype = Object.create(Array.prototype)\n\nSeaArray.prototype.toString = function (enc, start, end) {\n  if (!enc) enc = \"utf8\"\n  if (!start) start = 0\n\n  end = end ? Math.min(Math.max(end, start), this.length) : this.length\n\n  if (enc === \"hex\") {\n    const buf = new Uint8Array(this.slice(start, end))\n    return Array.from(buf, byte => byte.toString(16).padStart(2, \"0\")).join(\"\")\n  }\n\n  if (enc === \"utf8\") {\n    return Array.from({length: end - start}, (_, i) => {\n      const charCode = this[i + start]\n      // Use unicode replacement character for invalid character codes.\n      if (charCode < 0 || charCode > 0x10ffff) {\n        return String.fromCharCode(0xfffd)\n      }\n      return String.fromCharCode(charCode)\n    }).join(\"\")\n  }\n\n  if (enc === \"base64\") {\n    const utf8String = Array.from({length: end - start}, (_, i) => {\n      const charCode = this[i + start]\n      if (charCode < 0 || charCode > 255) {\n        return String.fromCharCode(0xfffd)\n      }\n      return String.fromCharCode(charCode)\n    }).join(\"\")\n    return btoa(utf8String)\n  }\n}\n\nexport default SeaArray\n", "import SeaArray from \"./array.js\"\n\n// Security constants\nconst SECURITY_LIMITS = {\n  MAX_BUFFER_SIZE: 10 * 1024 * 1024, // 10MB limit\n  MAX_STRING_LENGTH: 1024 * 1024, // 1MB string limit\n}\n\n// Secure Buffer implementation for SEA.js\n// Compatible with NodeJS safe-buffer but with enhanced security\nfunction SafeBuffer(...props) {\n  console.warn(\"new SafeBuffer() is deprecated, please use SafeBuffer.from()\")\n  return SafeBuffer.from(...props)\n}\n\nSafeBuffer.prototype = Object.create(Array.prototype)\n\n// Input validation helpers\nconst validateStringInput = (input, encoding) => {\n  if (typeof input !== \"string\") {\n    throw new TypeError(\"Input must be a string for encoding: \" + encoding)\n  }\n\n  if (input.length > SECURITY_LIMITS.MAX_STRING_LENGTH) {\n    throw new RangeError(\n      `String too large: ${input.length} > ${SECURITY_LIMITS.MAX_STRING_LENGTH}`,\n    )\n  }\n}\n\nconst validateBufferSize = (size, operation = \"buffer operation\") => {\n  if (size > SECURITY_LIMITS.MAX_BUFFER_SIZE) {\n    throw new RangeError(\n      `Buffer size too large for ${operation}: ${size} > ${SECURITY_LIMITS.MAX_BUFFER_SIZE}`,\n    )\n  }\n}\n\n// Secure hex parsing\nconst parseHexString = hexString => {\n  validateStringInput(hexString, \"hex\")\n\n  // Remove any whitespace and convert to lowercase\n  const cleanHex = hexString.replace(/\\s/g, \"\").toLowerCase()\n\n  // Validate hex format: only 0-9, a-f characters\n  if (!/^[0-9a-f]*$/.test(cleanHex)) {\n    throw new TypeError(\"Invalid hex string: contains non-hex characters\")\n  }\n\n  // Must be even length\n  if (cleanHex.length % 2 !== 0) {\n    throw new TypeError(\"Invalid hex string: must have even length\")\n  }\n\n  if (cleanHex.length === 0) {\n    return new Uint8Array(0)\n  }\n\n  validateBufferSize(cleanHex.length / 2, \"hex parsing\")\n\n  const bytes = new Uint8Array(cleanHex.length / 2)\n  for (let i = 0; i < cleanHex.length; i += 2) {\n    const hexByte = cleanHex.substr(i, 2)\n    bytes[i / 2] = parseInt(hexByte, 16)\n  }\n  return bytes\n}\n\nconst encodeUtf8String = str => {\n  validateStringInput(str, \"utf8\")\n\n  try {\n    // Use standard TextEncoder for proper UTF-8 encoding\n    const encoder = new TextEncoder()\n    const bytes = encoder.encode(str)\n\n    validateBufferSize(bytes.length, \"UTF-8 encoding\")\n    return bytes\n  } catch (err) {\n    throw new TypeError(\"Failed to encode UTF-8 string: \" + err.message)\n  }\n}\n\nconst encodeBinaryString = str => {\n  validateStringInput(str, \"binary\")\n\n  validateBufferSize(str.length, \"binary encoding\")\n\n  const bytes = new Uint8Array(str.length)\n  for (let i = 0; i < str.length; i++) {\n    const charCode = str.charCodeAt(i)\n\n    // Binary strings should only contain bytes (0-255)\n    if (charCode > 255) {\n      throw new TypeError(\n        `Invalid binary string: character at position ${i} exceeds byte range (${charCode} > 255)`,\n      )\n    }\n\n    bytes[i] = charCode\n  }\n  return bytes\n}\n\n// Secure base64 decoding\nconst parseBase64String = base64String => {\n  validateStringInput(base64String, \"base64\")\n\n  // Remove any whitespace\n  const cleanBase64 = base64String.replace(/\\s/g, \"\")\n\n  // Validate base64 format\n  if (!/^[A-Za-z0-9+/]*={0,2}$/.test(cleanBase64)) {\n    throw new TypeError(\"Invalid base64 string: contains invalid characters\")\n  }\n\n  try {\n    const decodedString = atob(cleanBase64)\n    validateBufferSize(decodedString.length, \"base64 decoding\")\n\n    const bytes = new Uint8Array(decodedString.length)\n    for (let i = 0; i < decodedString.length; i++) {\n      bytes[i] = decodedString.charCodeAt(i)\n    }\n\n    return bytes\n  } catch (err) {\n    throw new TypeError(\"Failed to decode base64 string: \" + err.message)\n  }\n}\n\n// Secure array-like input processing\nconst processArrayLikeInput = input => {\n  let bytes\n\n  if (input instanceof ArrayBuffer) {\n    validateBufferSize(input.byteLength, \"ArrayBuffer processing\")\n    bytes = new Uint8Array(input)\n  } else if (ArrayBuffer.isView(input)) {\n    validateBufferSize(\n      input.byteLength || input.length,\n      \"TypedArray processing\",\n    )\n    bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength)\n  } else if (Array.isArray(input)) {\n    validateBufferSize(input.length, \"Array processing\")\n\n    // Validate all array elements are valid byte values\n    for (let i = 0; i < input.length; i++) {\n      const val = input[i]\n      if (\n        typeof val !== \"number\" ||\n        val < 0 ||\n        val > 255 ||\n        !Number.isInteger(val)\n      ) {\n        throw new TypeError(\n          `Invalid byte value at index ${i}: ${val} (must be integer 0-255)`,\n        )\n      }\n    }\n\n    bytes = new Uint8Array(input)\n  } else if (\n    typeof input === \"object\" &&\n    input !== null &&\n    typeof input.length === \"number\"\n  ) {\n    // Handle array-like objects\n    validateBufferSize(input.length, \"array-like processing\")\n\n    const arr = Array.from(input)\n    for (let i = 0; i < arr.length; i++) {\n      const val = arr[i]\n      if (\n        typeof val !== \"number\" ||\n        val < 0 ||\n        val > 255 ||\n        !Number.isInteger(val)\n      ) {\n        throw new TypeError(\n          `Invalid byte value at index ${i}: ${val} (must be integer 0-255)`,\n        )\n      }\n    }\n\n    bytes = new Uint8Array(arr)\n  } else {\n    throw new TypeError(\"Unsupported input type: \" + typeof input)\n  }\n\n  return bytes\n}\n\nObject.assign(SafeBuffer, {\n  from() {\n    const argCount = arguments.length\n\n    if (argCount === 0) {\n      throw new TypeError(\"SafeBuffer.from() requires at least one argument\")\n    }\n\n    const input = arguments[0]\n\n    if (input === null || input === undefined) {\n      throw new TypeError(\"First argument must not be null or undefined\")\n    }\n\n    let bytes\n\n    if (typeof input === \"string\") {\n      const encoding = (arguments[1] || \"utf8\").toLowerCase()\n\n      switch (encoding) {\n        case \"hex\":\n          bytes = parseHexString(input)\n          break\n\n        case \"utf8\":\n        case \"utf-8\":\n          bytes = encodeUtf8String(input)\n          break\n\n        case \"binary\":\n        case \"latin1\":\n          bytes = encodeBinaryString(input)\n          break\n\n        case \"base64\":\n          bytes = parseBase64String(input)\n          break\n\n        case \"ascii\":\n          // ASCII is subset of UTF-8, but validate range\n          validateStringInput(input, \"ascii\")\n          for (let i = 0; i < input.length; i++) {\n            if (input.charCodeAt(i) > 127) {\n              throw new TypeError(\n                `Invalid ASCII character at position ${i}: ${input.charCodeAt(i)} > 127`,\n              )\n            }\n          }\n          bytes = encodeUtf8String(input) // Safe since ASCII is UTF-8 subset\n          break\n\n        default:\n          throw new TypeError(\"Unknown encoding: \" + encoding)\n      }\n    } else {\n      bytes = processArrayLikeInput(input)\n    }\n\n    if (!bytes || bytes.length === 0) {\n      return SeaArray.from(new Uint8Array(0))\n    }\n\n    try {\n      return SeaArray.from(bytes)\n    } catch (err) {\n      throw new Error(\"Failed to create SafeBuffer: \" + err.message)\n    }\n  },\n\n  alloc(length, fill = 0) {\n    if (typeof length !== \"number\" || !Number.isInteger(length) || length < 0) {\n      throw new TypeError(\"Length must be a non-negative integer\")\n    }\n\n    validateBufferSize(length, \"buffer allocation\")\n\n    // Validate fill value\n    if (typeof fill === \"number\") {\n      if (fill < 0 || fill > 255 || !Number.isInteger(fill)) {\n        throw new TypeError(\"Fill value must be an integer between 0 and 255\")\n      }\n    } else if (typeof fill === \"string\") {\n      if (fill.length !== 1) {\n        throw new TypeError(\"Fill string must be exactly one character\")\n      }\n      fill = fill.charCodeAt(0)\n      if (fill > 255) {\n        throw new TypeError(\"Fill character code must be <= 255\")\n      }\n    } else {\n      throw new TypeError(\"Fill must be a number or single character string\")\n    }\n\n    try {\n      const buffer = new Uint8Array(length)\n      if (fill !== 0) {\n        buffer.fill(fill)\n      }\n      return SeaArray.from(buffer)\n    } catch (err) {\n      throw new Error(\"Failed to allocate buffer: \" + err.message)\n    }\n  },\n\n  concat(arr) {\n    if (!Array.isArray(arr)) {\n      throw new TypeError(\"First argument must be an array\")\n    }\n\n    if (arr.length === 0) {\n      return SeaArray.from(new Uint8Array(0))\n    }\n\n    // Validate all array elements and calculate total size\n    let totalLength = 0\n    const validatedBuffers = []\n\n    for (let i = 0; i < arr.length; i++) {\n      const item = arr[i]\n\n      if (!item) {\n        throw new TypeError(`Array element at index ${i} is null or undefined`)\n      }\n\n      let bytes\n      try {\n        bytes = processArrayLikeInput(item)\n      } catch (err) {\n        throw new TypeError(\n          `Invalid array element at index ${i}: ${err.message}`,\n        )\n      }\n\n      totalLength += bytes.length\n      validateBufferSize(totalLength, \"buffer concatenation\")\n\n      validatedBuffers.push(bytes)\n    }\n\n    try {\n      const result = new Uint8Array(totalLength)\n      let offset = 0\n\n      for (const buffer of validatedBuffers) {\n        result.set(buffer, offset)\n        offset += buffer.length\n      }\n\n      return SeaArray.from(result)\n    } catch (err) {\n      throw new Error(\"Failed to concatenate buffers: \" + err.message)\n    }\n  },\n\n  // Helper method to check if object is SafeBuffer\n  isBuffer(obj) {\n    return (\n      obj instanceof SeaArray ||\n      (obj && typeof obj === \"object\" && obj.constructor === SafeBuffer)\n    )\n  },\n\n  // Get byte length of string in specific encoding\n  byteLength(string, encoding = \"utf8\") {\n    if (typeof string !== \"string\") {\n      throw new TypeError(\"First argument must be a string\")\n    }\n\n    switch (encoding.toLowerCase()) {\n      case \"utf8\":\n      case \"utf-8\":\n        return new TextEncoder().encode(string).length\n\n      case \"ascii\":\n      case \"binary\":\n      case \"latin1\":\n        return string.length\n\n      case \"base64\":\n        const clean = string.replace(/\\s/g, \"\")\n        return (\n          Math.floor((clean.length * 3) / 4) - (clean.match(/=/g) || []).length\n        )\n\n      case \"hex\":\n        return Math.floor(string.replace(/\\s/g, \"\").length / 2)\n\n      default:\n        throw new TypeError(\"Unknown encoding: \" + encoding)\n    }\n  },\n})\n\nSafeBuffer.prototype.from = SafeBuffer.from\nSafeBuffer.prototype.toString = function (\n  encoding = \"utf8\",\n  start = 0,\n  end = this.length,\n) {\n  // Input validation\n  if (typeof encoding !== \"string\") {\n    throw new TypeError(\"Encoding must be a string\")\n  }\n\n  if (typeof start !== \"number\" || !Number.isInteger(start) || start < 0) {\n    throw new TypeError(\"Start must be a non-negative integer\")\n  }\n\n  if (typeof end !== \"number\" || !Number.isInteger(end) || end < start) {\n    throw new TypeError(\"End must be an integer >= start\")\n  }\n\n  // Delegate to SeaArray with validation\n  try {\n    return SeaArray.prototype.toString.call(this, encoding, start, end)\n  } catch (err) {\n    throw new Error(\"Failed to convert buffer to string: \" + err.message)\n  }\n}\n\nexport default SafeBuffer\n", "import SafeBuffer from \"./buffer.js\"\n\nconst isNode = typeof document === \"undefined\"\nconst crypto = isNode\n  ? (await import(/*webpackIgnore: true*/ \"node:crypto\")).webcrypto\n  : globalThis.crypto\nexport const subtle = crypto.subtle\n\nexport const stringify = data => {\n  return typeof data === \"string\" ? data : JSON.stringify(data)\n}\n\nexport const parse = text => {\n  try {\n    return JSON.parse(text)\n  } catch {\n    return text\n  }\n}\n\nexport const random = length => {\n  const array = new Uint8Array(SafeBuffer.alloc(length))\n  return SafeBuffer.from(crypto.getRandomValues(array))\n}\n\nexport const jwk = (pub, priv) => {\n  const [x, y] = pub.split(\".\")\n  const ops = priv ? [\"sign\"] : [\"verify\"]\n  return {\n    kty: \"EC\",\n    crv: \"P-256\",\n    x: x,\n    y: y,\n    d: priv,\n    ext: true,\n    key_ops: ops,\n  }\n}\n\nexport const sha256 = async data => {\n  const hash = await subtle.digest(\n    {name: \"SHA-256\"},\n    new TextEncoder().encode(stringify(data)),\n  )\n  return SafeBuffer.from(hash)\n}\n\nexport const aeskey = async (key, salt) => {\n  const combined = key + salt.toString(\"utf8\")\n  const hash = SafeBuffer.from(await sha256(combined), \"binary\")\n  const jwk = keyToJwk(hash)\n  return await subtle.importKey(\"jwk\", jwk, {name: \"AES-GCM\"}, false, [\n    \"encrypt\",\n    \"decrypt\",\n  ])\n}\n\nconst keyToJwk = key => {\n  const k = key\n    .toString(\"base64\")\n    .replace(/\\+/g, \"-\")\n    .replace(/\\//g, \"_\")\n    .replace(/\\=/g, \"\")\n  return {kty: \"oct\", k: k, ext: false, alg: \"A256GCM\"}\n}\n", "import {userPublicKey, userSignature} from \"./utils.js\"\nimport * as utils from \"./sea-utils.js\"\nimport SafeBuffer from \"./buffer.js\"\n\n// Security, Encryption, and Authorization: SEA.js from GunDB.\nconst SEA = {\n  pair: async cb => {\n    // ECDSA keys for signing/verifying.\n    const ecdsa = await utils.subtle\n      .generateKey({name: \"ECDSA\", namedCurve: \"P-256\"}, true, [\n        \"sign\",\n        \"verify\",\n      ])\n      .then(async keys => {\n        const pub = await utils.subtle.exportKey(\"jwk\", keys.publicKey)\n        return {\n          priv: (await utils.subtle.exportKey(\"jwk\", keys.privateKey)).d,\n          pub: pub.x + \".\" + pub.y,\n        }\n      })\n\n    // ECDH keys for encryption/decryption.\n    const ecdh = await utils.subtle\n      .generateKey({name: \"ECDH\", namedCurve: \"P-256\"}, true, [\"deriveKey\"])\n      .then(async keys => {\n        const pub = await utils.subtle.exportKey(\"jwk\", keys.publicKey)\n        return {\n          epriv: (await utils.subtle.exportKey(\"jwk\", keys.privateKey)).d,\n          epub: pub.x + \".\" + pub.y,\n        }\n      })\n\n    const pair = {\n      pub: ecdsa.pub,\n      priv: ecdsa.priv,\n      epub: ecdh.epub,\n      epriv: ecdh.epriv,\n    }\n    if (cb) cb(pair)\n    return pair\n  },\n  encrypt: async (data, pair, cb) => {\n    if (!pair || !pair.epriv) {\n      if (cb) cb(null)\n      return null\n    }\n\n    const rand = {s: utils.random(9), iv: utils.random(15)}\n    const ct = await utils.aeskey(pair.epriv, rand.s).then(aes => {\n      return utils.subtle.encrypt(\n        {\n          name: \"AES-GCM\",\n          iv: new Uint8Array(rand.iv),\n        },\n        aes,\n        new TextEncoder().encode(utils.stringify(data)),\n      )\n    })\n    const enc = {\n      ct: SafeBuffer.from(ct, \"binary\").toString(\"base64\"),\n      iv: rand.iv.toString(\"base64\"),\n      s: rand.s.toString(\"base64\"),\n    }\n    if (cb) cb(enc)\n    return enc\n  },\n  decrypt: async (enc, pair, cb) => {\n    if (!enc || !enc.ct || !enc.iv || !enc.s || !pair || !pair.epriv) {\n      if (cb) cb(null)\n      return null\n    }\n\n    const data = {\n      ct: SafeBuffer.from(enc.ct, \"base64\"),\n      iv: SafeBuffer.from(enc.iv, \"base64\"),\n      s: SafeBuffer.from(enc.s, \"base64\"),\n    }\n    try {\n      const ct = await utils.aeskey(pair.epriv, data.s).then(aes => {\n        return utils.subtle.decrypt(\n          {\n            name: \"AES-GCM\",\n            iv: new Uint8Array(data.iv),\n            tagLength: 128,\n          },\n          aes,\n          new Uint8Array(data.ct),\n        )\n      })\n      const dec = utils.parse(new TextDecoder(\"utf8\").decode(ct))\n      if (cb) cb(dec)\n      return dec\n    } catch (err) {\n      // An error will be thrown if the wrong key is used.\n      if (cb) cb(null)\n      return null\n    }\n  },\n  verify: async (data, pair, cb) => {\n    if (!pair || !pair.pub) {\n      if (cb) cb(null)\n      return null\n    }\n\n    const signed = utils.parse(data)\n    const key = await utils.subtle.importKey(\n      \"jwk\",\n      utils.jwk(pair.pub),\n      {name: \"ECDSA\", namedCurve: \"P-256\"},\n      false,\n      [\"verify\"],\n    )\n\n    let msg = {}\n    if (typeof signed.m === \"string\") {\n      msg = signed.m\n    } else {\n      // Allow data to be passed in with graph meta data,\n      // (which should not be part of signature, so not verified).\n      for (const k of Object.keys(signed.m).sort()) {\n        if (k !== \"_\" && k !== userPublicKey && k !== userSignature) {\n          msg[k] = signed.m[k]\n        }\n      }\n    }\n    const hash = await utils.sha256(msg)\n    const sig = new Uint8Array(SafeBuffer.from(signed.s, \"base64\"))\n    const alg = {name: \"ECDSA\", hash: {name: \"SHA-256\"}}\n    if (await utils.subtle.verify(alg, key, sig, new Uint8Array(hash))) {\n      const verified = utils.parse(signed.m)\n      if (cb) cb(verified)\n      return verified\n    }\n\n    if (cb) cb(null)\n    return null\n  },\n  // Verify individual property signatures stored in node._[\"s\"]\n  // Returns array of valid property names\n  verifyProperties: async (node, pub, cb) => {\n    if (!pub || !node) {\n      if (cb) cb([])\n      return []\n    }\n\n    const key = await utils.subtle.importKey(\n      \"jwk\",\n      utils.jwk(pub),\n      {name: \"ECDSA\", namedCurve: \"P-256\"},\n      false,\n      [\"verify\"],\n    )\n\n    const alg = {name: \"ECDSA\", hash: {name: \"SHA-256\"}}\n    const valid = []\n    const propertySignatures = (node._ && node._[\"s\"]) || {}\n\n    // Verify each property individually\n    for (const k of Object.keys(node).sort()) {\n      if (k === \"_\" || k == userPublicKey) continue\n\n      const propSig = propertySignatures[k]\n      if (!propSig) {\n        console.log(`warning: property '${k}' missing signature`)\n        continue\n      }\n\n      try {\n        const hash = await utils.sha256(node[k])\n        const sig = new Uint8Array(SafeBuffer.from(propSig, \"base64\"))\n\n        const isValid = await utils.subtle.verify(\n          alg,\n          key,\n          sig,\n          new Uint8Array(hash),\n        )\n        if (isValid) {\n          valid.push(k)\n        } else {\n          console.log(`warning: property '${k}' signature verification failed`)\n        }\n      } catch (err) {\n        console.log(`warning: property '${k}' error verifying: ${err.message}`)\n      }\n    }\n\n    if (cb) cb(valid)\n    return valid\n  },\n  sign: async (data, pair, cb) => {\n    if (!pair || !pair.pub || !pair.priv) {\n      if (cb) cb(null)\n      return null\n    }\n\n    let msg = {}\n    if (typeof data === \"string\") {\n      msg = data\n    } else {\n      const check = utils.parse(data)\n      for (const k of Object.keys(check).sort()) {\n        if (k !== \"_\" && k !== userPublicKey && k !== userSignature) {\n          msg[k] = check[k]\n        }\n      }\n    }\n    const hash = await utils.sha256(msg)\n    const jwk = utils.jwk(pair.pub, pair.priv)\n    const alg = {name: \"ECDSA\", namedCurve: \"P-256\"}\n    const sig = await utils.subtle\n      .importKey(\"jwk\", jwk, alg, false, [\"sign\"])\n      .then(key =>\n        utils.subtle.sign(\n          {name: \"ECDSA\", hash: {name: \"SHA-256\"}},\n          key,\n          new Uint8Array(hash),\n        ),\n      )\n    const signed = {\n      m: msg,\n      s: SafeBuffer.from(sig, \"binary\").toString(\"base64\"),\n    }\n\n    if (cb) cb(signed)\n    return signed\n  },\n  // Sign individual properties for per-property verification\n  signProperties: async (data, pair, cb) => {\n    if (!pair || !pair.pub || !pair.priv) {\n      if (cb) cb(null)\n      return null\n    }\n\n    const check = utils.parse(data)\n    const propertySignatures = {}\n    const jwk = utils.jwk(pair.pub, pair.priv)\n    const alg = {name: \"ECDSA\", namedCurve: \"P-256\"}\n    const key = await utils.subtle.importKey(\"jwk\", jwk, alg, false, [\"sign\"])\n\n    // Sign each property individually\n    for (const k of Object.keys(check).sort()) {\n      if (k !== \"_\" && k != userPublicKey && k != userSignature) {\n        const hash = await utils.sha256(check[k])\n        const sig = await utils.subtle.sign(\n          {name: \"ECDSA\", hash: {name: \"SHA-256\"}},\n          key,\n          new Uint8Array(hash),\n        )\n        propertySignatures[k] = SafeBuffer.from(sig, \"binary\").toString(\n          \"base64\",\n        )\n      }\n    }\n\n    if (cb) cb(propertySignatures)\n    return propertySignatures\n  },\n  work: async (data, salt, cb) => {\n    if (typeof salt === \"function\") {\n      cb = salt\n      salt = undefined\n    }\n    if (typeof salt === \"undefined\") salt = utils.random(9)\n\n    const key = await utils.subtle.importKey(\n      \"raw\",\n      new TextEncoder().encode(utils.stringify(data)),\n      {name: \"PBKDF2\"},\n      false,\n      [\"deriveBits\"],\n    )\n    const alg = {\n      name: \"PBKDF2\",\n      iterations: 100000,\n      salt: new TextEncoder().encode(salt),\n      hash: {name: \"SHA-256\"},\n    }\n    const work = await utils.subtle.deriveBits(alg, key, 512)\n    // Use \"pair\" format so that work can be used as epriv by decrypt.\n    const pair = {epriv: SafeBuffer.from(work, \"binary\").toString(\"base64\")}\n    if (cb) cb(pair)\n    return pair\n  },\n  secret: async (to, from, cb) => {\n    if (!to || !to.epub || !from || !from.epub || !from.epriv) {\n      if (cb) cb(null)\n      return null\n    }\n\n    const alg = {name: \"ECDH\", namedCurve: \"P-256\"}\n    const pub = utils.jwk(to.epub)\n    const pubKey = await utils.subtle.importKey(\"jwk\", pub, alg, true, [])\n    const priv = utils.jwk(from.epub, from.epriv, false)\n    // utils.jwk provides default key_ops but it shouldn't be used here.\n    delete priv.key_ops\n    const derived = await utils.subtle\n      .importKey(\"jwk\", priv, alg, false, [\"deriveBits\"])\n      .then(async key => {\n        const derivedBits = await utils.subtle.deriveBits(\n          {public: pubKey, name: \"ECDH\", namedCurve: \"P-256\"},\n          key,\n          256,\n        )\n        const derivedKey = await utils.subtle.importKey(\n          \"raw\",\n          new Uint8Array(derivedBits),\n          {name: \"AES-GCM\", length: 256},\n          true,\n          [\"encrypt\", \"decrypt\"],\n        )\n        return utils.subtle.exportKey(\"jwk\", derivedKey).then(({k}) => k)\n      })\n    // Use \"pair\" format so that secret can be used as epriv by encrypt.\n    if (cb) cb({epriv: derived})\n    return {epriv: derived}\n  },\n}\n\nexport default SEA\n", "import * as utils from \"./utils.js\"\nimport SEA from \"./sea.js\"\n\nconst LISTENER_DELAY = 100\n// Maximum number of souls to keep in memory\nconst MAX_GRAPH_SIZE = 10000\n\n// state and value are the incoming changes.\n// currentState and currentValue are the current graph data.\nconst Ham = (state, currentState, value, currentValue) => {\n  if (state < currentState) return {historical: true}\n\n  if (state > currentState) return {incoming: true}\n\n  // state is equal to currentState, lexically compare to resolve conflict.\n  if (typeof value !== \"string\") {\n    value = JSON.stringify(value) || \"\"\n  }\n  if (typeof currentValue !== \"string\") {\n    currentValue = JSON.stringify(currentValue) || \"\"\n  }\n  // No update required.\n  if (value === currentValue) return {state: true}\n\n  // Keep the current value.\n  if (value < currentValue) return {current: true}\n\n  // Otherwise update using the incoming value.\n  return {incoming: true}\n}\n\nHam.mix = async (change, graph, secure, listen) => {\n  if (!change || typeof change !== \"object\") {\n    throw new TypeError(\"change must be an object\")\n  }\n  if (!graph || typeof graph !== \"object\") {\n    throw new TypeError(\"graph must be an object\")\n  }\n  if (!listen || typeof listen !== \"object\") {\n    throw new TypeError(\"listen must be an object\")\n  }\n\n  const machine = Date.now()\n  const now = {}\n  const defer = {}\n  const validProperties = new Map() // Track valid properties per soul\n  let wait = 0\n\n  for (const soul of Object.keys(change)) {\n    const node = change[soul]\n    let updated = false\n    let alias = false\n    let nodeWait = 0\n    let verify = secure\n\n    if (!node || !node._) continue\n\n    const pub = node[utils.userPublicKey]\n    // If per-property signatures and public key are provided then always verify.\n    if (node._[\"s\"] && pub) verify = true\n\n    // Special case if soul starts with \"~\". Node must be system data ie,\n    // ~@alias or ~publickey. For aliases, key and value must be a self\n    // identifying rel. For public keys, data needs to be signed and verified.\n    // (This is also true for any data when the secure flag is used.)\n    if (soul.length > 1 && soul[0] === \"~\") {\n      if (soul[1] === \"@\") {\n        alias = true\n        verify = false\n      } else {\n        if (pub && soul != \"~\" + pub) {\n          console.log(`error public key does not match for soul: ${soul}`)\n          continue\n        }\n\n        verify = true\n      }\n    }\n    if (verify) {\n      // Per-property signatures stored in node._[\"s\"]\n      if (!pub || !node._) {\n        continue\n      }\n\n      // Verify properties individually, returns array of valid property names\n      const validProps = await SEA.verifyProperties(node, pub)\n\n      // If no properties verified, skip this update\n      if (validProps.length === 0) {\n        continue\n      }\n\n      // Track valid properties for this soul\n      validProperties.set(soul, new Set(validProps))\n    }\n\n    for (const key of Object.keys(node)) {\n      if (key === \"_\") continue\n\n      // Skip metadata fields (including userSignature for old data)\n      if (key === utils.userSignature || key === utils.userPublicKey) continue\n\n      // If this soul had verification, only process properties that have valid signatures\n      // Properties without signatures in this update are left unchanged\n      if (validProperties.has(soul) && !validProperties.get(soul).has(key)) {\n        continue\n      }\n\n      const value = node[key]\n      const state = node._ && node._[\">\"] ? node._[\">\"][key] : 0\n      const currentValue = (graph[soul] || {})[key]\n      const currentState = (graph[soul] || {_: {\">\": {}}})._[\">\"][key] || 0\n\n      if (alias && key !== utils.rel.is(value)) {\n        console.log(`error alias ${alias}: ${key} !== ${utils.rel.is(value)}`)\n        continue\n      }\n\n      // Defer the update if ahead of machine time.\n      const skew = state - machine\n      if (skew > 0) {\n        // Ignore update if ahead by more than 24 hours.\n        if (skew > 86400000) continue\n\n        // Wait the shortest difference before trying the updates again.\n        if (wait === 0 || skew < wait) wait = nodeWait = skew\n        if (!defer[soul]) {\n          defer[soul] = {_: {\"#\": soul, \">\": {}, s: {}}}\n        }\n        defer[soul][key] = value\n        defer[soul]._[\">\"][key] = state\n        if (node._[\"s\"] && node._[\"s\"][key]) {\n          defer[soul]._[\"s\"][key] = node._[\"s\"][key]\n        }\n      } else {\n        const result = Ham(state, currentState, value, currentValue)\n        if (result.incoming) {\n          if (!now[soul]) {\n            now[soul] = {_: {\"#\": soul, \">\": {}, s: {}}}\n          }\n          if (!graph[soul]) {\n            graph[soul] = {_: {\"#\": soul, \">\": {}, s: {}}}\n          }\n          graph[soul][key] = now[soul][key] = value\n          graph[soul]._[\">\"][key] = now[soul]._[\">\"][key] = state\n          if (node._[\"s\"] && node._[\"s\"][key]) {\n            graph[soul]._[\"s\"][key] = now[soul]._[\"s\"][key] = node._[\"s\"][key]\n          }\n          // Call event listeners for update on key, mix is called before\n          // put has finished so wait for what could be multiple nested\n          // updates on a node.\n          if (listen[soul]) {\n            setTimeout(() => {\n              if (listen[soul]) {\n                listen[soul]\n                  .filter(l => utils.match(l[\".\"], key))\n                  .forEach(l => l.cb())\n              }\n            }, LISTENER_DELAY)\n          }\n          updated = true\n        }\n      }\n    }\n\n    if (verify && nodeWait !== 0 && now[soul]) {\n      // Secure updates can't be split, so move now to deferred as well.\n      Object.assign(defer[soul], now[soul])\n      delete now[soul]\n    }\n    // Call event listeners for update on soul.\n    if (updated && listen[soul]) {\n      setTimeout(() => {\n        if (listen[soul]) {\n          listen[soul].filter(l => utils.match(l[\".\"])).forEach(l => l.cb())\n        }\n      }, LISTENER_DELAY)\n    }\n  }\n\n  const souls = Object.keys(graph)\n  if (souls.length > MAX_GRAPH_SIZE) {\n    // Sort by oldest state timestamp and remove oldest entries\n    const soulsByAge = souls\n      .map(soul => {\n        const states = graph[soul]._ && graph[soul]._[\">\"]\n        const maxState = states ? Math.max(...Object.values(states)) : 0\n        return {soul, maxState}\n      })\n      .sort((a, b) => a.maxState - b.maxState)\n    const remove = soulsByAge.slice(0, souls.length - MAX_GRAPH_SIZE)\n    remove.forEach(({soul}) => delete graph[soul])\n  }\n\n  return {now: now, defer: defer, wait: wait}\n}\n\nexport default Ham\n", "import * as utils from \"./utils.js\"\n\n// ASCII character for group separator.\nconst group = String.fromCharCode(29)\n// ASCII character for record separator.\nconst record = String.fromCharCode(30)\n\nconst Radix = () => {\n  const radix = (keys, value, tree) => {\n    if (!tree) {\n      if (!radix[group]) radix[group] = {}\n      tree = radix[group]\n    }\n    if (!keys) return tree\n\n    let i = 0\n    let tmp = {}\n    let key = keys[i]\n    const max = keys.length - 1\n    const noValue = typeof value === \"undefined\"\n    // Find a matching value using the shortest string from keys.\n    let found = tree[key]\n    while (!found && i < max) {\n      key += keys[++i]\n      found = tree[key]\n    }\n\n    if (!found) {\n      // If not found from the provided keys try matching with an existing key.\n      const result = utils.obj.map(tree, (hasValue, hasKey) => {\n        let j = 0\n        let matchingKey = \"\"\n        while (hasKey[j] === keys[j]) {\n          matchingKey += hasKey[j++]\n        }\n        if (matchingKey) {\n          if (noValue) {\n            // matchingKey has to be as long as the original keys when reading.\n            if (j <= max) return\n\n            tmp[hasKey.slice(j)] = hasValue\n            return hasValue\n          }\n\n          let replace = {\n            [hasKey.slice(j)]: hasValue,\n            [keys.slice(j)]: {[record]: value},\n          }\n          tree[matchingKey] = {[group]: replace}\n          delete tree[hasKey]\n          return true\n        }\n      })\n      if (!result) {\n        if (noValue) return\n\n        if (!tree[key]) tree[key] = {}\n        tree[key][record] = value\n      } else if (noValue) {\n        return tmp\n      }\n    } else if (i === max) {\n      // If no value use the key provided to return a whole group or record.\n      if (noValue) {\n        // If an individual record isn't found then return the whole group.\n        return typeof found[record] === \"undefined\"\n          ? found[group]\n          : found[record]\n      }\n      // Otherwise create a new record at the provided key for value.\n      found[record] = value\n    } else {\n      // Found at a shorter key, try again.\n      if (!found[group] && !noValue) found[group] = {}\n      return radix(keys.slice(++i), value, found[group])\n    }\n  }\n  return radix\n}\n\nRadix.map = function map(radix, cb, opt, pre) {\n  if (!pre) pre = []\n  var tree = radix[group] || radix\n  var keys = Object.keys(tree).sort()\n  var u\n\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i]\n    let found = tree[key]\n    let tmp = found[record]\n    if (typeof tmp !== \"undefined\") {\n      tmp = cb(tmp, pre.join(\"\") + key, key, pre)\n      if (typeof tmp !== \"undefined\") return tmp\n    } else if (opt) {\n      cb(u, pre.join(\"\"), key, pre)\n    }\n    if (found[group]) {\n      pre.push(key)\n      tmp = map(found[group], cb, opt, pre)\n      if (typeof tmp !== \"undefined\") return tmp\n      pre.pop()\n    }\n  }\n}\n\nexport default Radix\n", "import Radix from \"./radix.js\"\nimport * as utils from \"./utils.js\"\n\n// ASCII character for end of text\nconst etx = String.fromCharCode(3)\n// ASCII character for enquiry\nconst enq = String.fromCharCode(5)\n// ASCII character for unit separator\nconst unit = String.fromCharCode(31)\n\n// Radisk provides access to a radix tree that is stored in the provided\n// opt.store interface\nconst Radisk = opt => {\n  var u\n\n  // Multi-file cache for all parsed radix trees\n  const cache = new Map()\n  // File listing cache to avoid repeated directory scans\n  let fileListCache = null\n  let fileListCacheTime = 0\n  const FILE_LIST_CACHE_TTL = 10000 // 10 seconds\n  // Pending reads queue to avoid duplicate reads for the same key\n  const pendingReads = new Map()\n\n  // Memory monitoring and cleanup\n  let lastMemoryCheck = 0\n  const MEMORY_CHECK_INTERVAL = 30000 // Check every 30 seconds\n  const HEAP_WARNING_THRESHOLD = 0.8 // Warn at 80% of max heap size\n  const HEAP_CLEANUP_THRESHOLD = 0.9 // Clean cache at 90% of max heap size\n\n  if (!opt) opt = {}\n  if (!opt.log) opt.log = console.log\n  if (!opt.batch) opt.batch = 100 // Balanced batch size for performance\n  if (!opt.write) opt.write = 1 // Wait time before write in milliseconds\n  if (!opt.size) opt.size = 1024 * 1024 // File size on disk, default 1MB\n  if (!opt.memoryLimit) opt.memoryLimit = 500 // Memory limit in MB\n  if (typeof opt.cache === \"undefined\") opt.cache = true\n\n  if (!opt.store) {\n    opt.log(\n      \"Radisk needs `store` interface with `{get: fn, put: fn, list: fn}`\",\n    )\n    return\n  }\n  if (!opt.store.get) {\n    opt.log(\"Radisk needs `store.get` interface with `(file, cb)`\")\n    return\n  }\n  if (!opt.store.put) {\n    opt.log(\"Radisk needs `store.put` interface with `(file, data, cb)`\")\n    return\n  }\n  if (!opt.store.list) {\n    opt.log(\"Radisk needs a streaming `store.list` interface with `(cb)`\")\n    return\n  }\n\n  // Performance logging\n  const perfLog = (operation, startTime, key, size) => {\n    const duration = Date.now() - startTime\n    if (duration > 2000) {\n      console.log(\n        `[RADISK-SLOW] ${operation}: ${duration}ms for ${key}${size ? ` (${size} bytes)` : \"\"}`,\n      )\n    }\n  }\n\n  // Memory monitoring and cache cleanup\n  const checkMemoryUsage = () => {\n    if (typeof process === \"undefined\" || !process.memoryUsage) return\n\n    const now = Date.now()\n    if (now - lastMemoryCheck < MEMORY_CHECK_INTERVAL) return\n    lastMemoryCheck = now\n\n    const memUsage = process.memoryUsage()\n    const heapUsed = memUsage.heapUsed\n    const heapTotal = memUsage.heapTotal\n    const maxHeapSize = opt.memoryLimit * 1024 * 1024\n    const heapUsageRatio = heapUsed / maxHeapSize\n\n    if (heapUsageRatio > HEAP_CLEANUP_THRESHOLD) {\n      const cacheSize = cache.size\n      console.log(\n        `[RADISK-MEMORY] High memory usage: ${Math.round(heapUsageRatio * 100)}% of heap limit. Clearing ${cacheSize} cached files.`,\n      )\n      cache.clear()\n      // Force garbage collection if available\n      if (global.gc) {\n        global.gc()\n      }\n      // Reset timer to avoid immediate re-check until GC has time to work\n      lastMemoryCheck = now + MEMORY_CHECK_INTERVAL\n    } else if (heapUsageRatio > HEAP_WARNING_THRESHOLD) {\n      console.log(\n        `[RADISK-MEMORY] Memory warning: ${Math.round(heapUsageRatio * 100)}% of heap limit used. Cache size: ${cache.size} files.`,\n      )\n    }\n  }\n\n  // Any and all storage adapters should:\n  // 1. Because writing to disk takes time, we should batch data to disk.\n  //    This improves performance, and reduces potential disk corruption.\n  // 2. If a batch exceeds a certain number of writes, we should immediately\n  //    write to disk when physically possible. This caps total performance,\n  //    but reduces potential loss.\n  const radisk = (key, value, cb) => {\n    key = \"\" + key\n\n    // If no value is provided then the second parameter is the callback\n    // function. Read value from memory or disk and call callback with it.\n    if (typeof value === \"function\") {\n      cb = value\n      value = radisk.batch(key)\n      if (typeof value !== \"undefined\") {\n        return cb(u, value)\n      }\n\n      if (radisk.thrash.at) {\n        value = radisk.thrash.at(key)\n        if (typeof value !== \"undefined\") {\n          return cb(u, value)\n        }\n      }\n\n      // Check if there's already a pending read for this key\n      if (pendingReads.has(key)) {\n        // Add callback to existing pending read\n        pendingReads.get(key).push(cb)\n        return\n      }\n\n      // Start new read and create callback queue\n      pendingReads.set(key, [cb])\n\n      const readStart = Date.now()\n      return radisk.read(key, (err, result) => {\n        perfLog(\"read\", readStart, key)\n        // Execute all pending callbacks for this key\n        const callbacks = pendingReads.get(key) || []\n        pendingReads.delete(key)\n        callbacks.forEach(callback => callback(err, result))\n      })\n    }\n\n    // Otherwise store the value provided.\n    radisk.batch(key, value)\n    // Check memory usage after writing to in-memory radix tree\n    checkMemoryUsage()\n    if (cb) {\n      radisk.batch.acks.push(cb)\n    }\n    // Don't wait if we have batched too many.\n    if (++radisk.batch.ed >= opt.batch) {\n      return radisk.thrash()\n    }\n\n    // Otherwise wait for more updates before writing.\n    clearTimeout(radisk.batch.timeout)\n    radisk.batch.timeout = setTimeout(radisk.thrash, opt.write)\n  }\n\n  radisk.batch = Radix()\n  radisk.batch.acks = []\n  radisk.batch.ed = 0\n\n  radisk.thrash = () => {\n    if (radisk.thrash.ing) {\n      return (radisk.thrash.more = true)\n    }\n\n    const thrashStart = Date.now()\n    clearTimeout(radisk.batch.timeout)\n    radisk.thrash.more = false\n    radisk.thrash.ing = true\n    var batch = (radisk.thrash.at = radisk.batch)\n    radisk.batch = null\n    radisk.batch = Radix()\n    radisk.batch.acks = []\n    radisk.batch.ed = 0\n    let i = 0\n    radisk.save(batch, err => {\n      // This is to ignore multiple callbacks from radisk.save calling\n      // radisk.write? It looks like multiple callbacks will be made if a\n      // file needs to be split.\n      if (++i > 1) return\n\n      perfLog(\"thrash\", thrashStart, `batch-${batch.ed}`)\n      if (err) opt.log(err)\n      batch.acks.forEach(cb => cb(err))\n      radisk.thrash.at = null\n      radisk.thrash.ing = false\n      if (radisk.thrash.more) radisk.thrash()\n    })\n  }\n\n  // 1. Find the first radix item in memory\n  // 2. Use that as the starting index in the directory of files\n  // 3. Find the first file that is lexically larger than it\n  // 4. Read the previous file into memory\n  // 5. Scan through in memory radix for all values lexically less than limit\n  // 6. Merge and write all of those to the in-memory file and back to disk\n  radisk.save = (rad, cb) => {\n    const save = {\n      find: (tree, key) => {\n        // This is false for any key until save.start is set to an initial key.\n        if (key < save.start) return\n\n        save.start = key\n        opt.store.list(save.lex)\n        return true\n      },\n      lex: file => {\n        if (!file || file > save.start) {\n          save.end = file\n          // ! is used as the first file name as it's the first printable\n          // character, so always matches as lexically less than any node.\n          // Also save.start can be set to undefined by a previous call to\n          // save.mix, so don't continue in this case.\n          if (save.start) save.mix(save.file || \"!\", save.start, save.end)\n        } else {\n          save.file = file\n        }\n      },\n      mix: (file, start, end) => {\n        save.start = save.end = save.file = u\n        // Use cache if available, otherwise parse from disk\n        if (cache.has(file)) {\n          const disk = cache.get(file)\n          Radix.map(rad, (value, key) => {\n            if (key < start) return\n\n            if (end && end < key) {\n              save.start = key\n              return\n            }\n\n            disk(key, value)\n          })\n          radisk.write(file, disk, save.next)\n        } else {\n          radisk.parse(file, (err, disk) => {\n            if (err) return cb(err)\n\n            Radix.map(rad, (value, key) => {\n              if (key < start) return\n\n              if (end && end < key) {\n                save.start = key\n                return\n              }\n\n              disk(key, value)\n            })\n            radisk.write(file, disk, save.next)\n          })\n        }\n      },\n      next: err => {\n        if (err) return cb(err)\n\n        if (save.start) return Radix.map(rad, save.find)\n\n        cb(err)\n      },\n    }\n    Radix.map(rad, save.find)\n  }\n\n  radisk.write = (file, rad, cb) => {\n    const write = {\n      text: \"\",\n      limit: \"\",\n      done: false,\n      count: 0,\n      each: (value, key, k, pre) => {\n        // each is called for all keys, but stop adding to write.text when\n        // write.slice is called, then the current contents of write.text\n        // will be written to file.\n        if (write.done) return\n\n        write.count++\n        value = typeof value === \"undefined\" ? \"\" : \"=\" + Radisk.encode(value)\n        const enc =\n          Radisk.encode(pre.length) + \"#\" + Radisk.encode(k) + value + \"\\n\"\n        // Cannot split the file if only have one entry to write. Also don't\n        // start a split if in the middle of writing a node (pre > 0).\n        if (\n          write.count > 1 &&\n          pre.length === 0 &&\n          write.text.length + enc.length > opt.size\n        ) {\n          const end = k.indexOf(enq)\n          write.limit = end === -1 ? k : k.substring(0, end)\n          // Cannot split if they key is the same as the current file name.\n          if (write.limit !== file) {\n            write.done = true\n            write.sub = Radix()\n            Radix.map(rad, write.slice)\n            radisk.write(write.limit, write.sub, cb)\n            return\n          }\n        }\n\n        write.text += enc\n      },\n      slice: (value, key) => {\n        if (key < write.limit) return\n\n        write.sub(key, value)\n      },\n    }\n    Radix.map(rad, write.each, true)\n    // There is always accumulated write.text to store once write.each has\n    // finished.\n    const writeStart = Date.now()\n    opt.store.put(file, write.text, err => {\n      perfLog(\"file-write\", writeStart, file, write.text.length)\n      cb(err)\n    })\n  }\n\n  radisk.read = (key, cb) => {\n    // Only the soul of the key is compared to filenames (see radisk.write).\n    const end = key.indexOf(enq)\n    const soul = end === -1 ? key : key.substring(0, end)\n\n    const read = {\n      lex: file => {\n        // store.list should call lex without a file last, which means all file\n        // names were compared to soul, so the current read.file is ok to use.\n        if (!file) {\n          if (!read.file) {\n            cb(\"no file found\", u)\n            return\n          }\n\n          // Check multi-file cache first\n          if (opt.cache && cache.has(read.file)) {\n            const cachedRadix = cache.get(read.file)\n            read.value = cachedRadix(key)\n            // Return cached result (defined or undefined) since in-memory\n            // radix tree is authoritative\n            return cb(u, read.value)\n          }\n\n          radisk.parse(read.file, read.it)\n          return\n        }\n\n        // Want the filename closest to soul.\n        if (file > soul || file < read.file) return\n\n        read.file = file\n      },\n      it: (err, disk) => {\n        if (err) opt.log(err)\n        if (disk) {\n          if (opt.cache) {\n            cache.set(read.file, disk)\n            checkMemoryUsage() // Check memory usage after adding to cache\n          }\n          read.value = disk(key)\n        }\n        cb(err, read.value)\n      },\n    }\n    const now = Date.now()\n    if (\n      opt.cache &&\n      fileListCache &&\n      now - fileListCacheTime < FILE_LIST_CACHE_TTL\n    ) {\n      // Use cached file list\n      fileListCache.forEach(file => read.lex(file))\n      read.lex() // Signal end of list\n    } else {\n      // Refresh cache\n      const files = []\n      const originalLex = read.lex\n      read.lex = file => {\n        if (file) files.push(file)\n        return originalLex(file)\n      }\n\n      opt.store.list(file => {\n        read.lex(file)\n        if (!file && opt.cache) {\n          // End of list - cache the results\n          fileListCache = files\n          fileListCacheTime = now\n        }\n      })\n    }\n  }\n\n  // Let us start by assuming we are the only process that is\n  // changing the directory or bucket. Not because we do not want\n  // to be multi-process/machine, but because we want to experiment\n  // with how much performance and scale we can get out of only one.\n  // Then we can work on the harder problem of being multi-process.\n  radisk.parse = (file, cb) => {\n    const parse = {\n      disk: Radix(),\n      read: (err, data) => {\n        if (err) return cb(err)\n\n        if (!data) return cb(u, parse.disk)\n\n        let pre = []\n        let preString = \"\"\n        // Work though data by splitting into 3 values. The first value says\n        // if the second value is one of: the radix level for a key, the key\n        // iteself, or a value. The third is the rest of the data to work with.\n        let tmp = parse.split(data)\n        while (tmp) {\n          let key\n          let value\n          let i = tmp[1]\n          tmp = parse.split(tmp[2]) || \"\"\n          if (tmp[0] === \"#\") {\n            key = tmp[1]\n            // Optimize prefix building - avoid repeated joins\n            if (i < pre.length) {\n              pre.length = i\n            }\n            if (i <= pre.length) {\n              pre[i] = key\n              pre.length = i + 1\n            }\n            // Only rebuild preString when prefix changes\n            preString = pre.join(\"\")\n          }\n          tmp = parse.split(tmp[2]) || \"\"\n          if (tmp[0] === \"\\n\") continue\n\n          if (tmp[0] === \"=\") value = tmp[1]\n          if (typeof key !== \"undefined\" && typeof value !== \"undefined\") {\n            parse.disk(preString, value)\n          }\n          tmp = parse.split(tmp[2])\n        }\n        cb(u, parse.disk)\n      },\n      split: data => {\n        if (!data) return\n\n        const i = data.indexOf(unit)\n        if (i === -1) return\n\n        const a = data.slice(0, i)\n        let o = {}\n        return [a, Radisk.decode(data.slice(i), o), data.slice(i + o.i)]\n      },\n    }\n    opt.store.get(file, parse.read)\n  }\n\n  return radisk\n}\n\nRadisk.encode = data => {\n  // A key should be passed in as a string to encode, a value can optionally be\n  // an array of 2-3 items: [value, state] or [value, state, signature].\n  let state = \"\"\n  let sig = \"\"\n  if (data instanceof Array && (data.length === 2 || data.length === 3)) {\n    state = etx + data[1]\n    if (data.length === 3 && data[2]) {\n      sig = etx + data[2]\n    }\n    data = data[0]\n  }\n\n  if (typeof data === \"string\") {\n    let i = 0\n    let current = null\n    let text = unit\n    while ((current = data[i++])) {\n      if (current === unit) text += unit\n    }\n    return text + '\"' + data + state + sig + unit\n  }\n\n  const rel = utils.rel.is(data)\n  if (rel) return unit + \"#\" + rel + state + sig + unit\n\n  if (utils.num.is(data)) return unit + \"+\" + (data || 0) + state + sig + unit\n\n  if (data === true) return unit + \"+\" + state + sig + unit\n\n  if (data === false) return unit + \"-\" + state + sig + unit\n\n  if (data === null) return unit + \" \" + state + sig + unit\n}\n\nRadisk.decode = (data, obj) => {\n  var i = -1\n  var n = 0\n  var current = null\n  var previous = null\n  var textStart = -1\n  var textEnd = -1\n  if (data[0] !== unit) return\n\n  // Find a control character previous to the text we want, skipping\n  // consecutive unit separator characters at the beginning of the data.\n  while ((current = data[++i])) {\n    if (previous) {\n      if (textStart === -1) textStart = i\n      if (current === unit) {\n        if (--n <= 0) {\n          textEnd = i\n          break\n        }\n      }\n    } else if (current === unit) {\n      n++\n    } else {\n      previous = current || true\n    }\n  }\n\n  const text =\n    textStart !== -1 ? data.slice(textStart, textEnd !== -1 ? textEnd : i) : \"\"\n\n  if (obj) obj.i = i + 1\n\n  let parts = text.split(etx)\n  let value = parts[0]\n  let state = parts[1]\n  let sig = parts[2]\n\n  if (!state) {\n    if (previous === '\"') return text\n\n    if (previous === \"#\") return utils.rel.ify(text)\n\n    if (previous === \"+\") {\n      if (text.length === 0) return true\n\n      return parseFloat(text)\n    }\n\n    if (previous === \"-\") return false\n\n    if (previous === \" \") return null\n  } else {\n    state = parseFloat(state)\n    // If state was found then return an array with [value, state] or [value, state, sig]\n    if (sig) {\n      if (previous === '\"') return [value, state, sig]\n\n      if (previous === \"#\") return [utils.rel.ify(value), state, sig]\n\n      if (previous === \"+\") {\n        if (value.length === 0) return [true, state, sig]\n\n        return [parseFloat(value), state, sig]\n      }\n\n      if (previous === \"-\") return [false, state, sig]\n\n      if (previous === \" \") return [null, state, sig]\n    } else {\n      if (previous === '\"') return [value, state]\n\n      if (previous === \"#\") return [utils.rel.ify(value), state]\n\n      if (previous === \"+\") {\n        if (value.length === 0) return [true, state]\n\n        return [parseFloat(value), state]\n      }\n\n      if (previous === \"-\") return [false, state]\n\n      if (previous === \" \") return [null, state]\n    }\n  }\n}\n\nexport default Radisk\n", "import Radisk from \"./radisk.js\"\nimport Radix from \"./radix.js\"\nimport * as utils from \"./utils.js\"\n\nconst isNode = typeof document === \"undefined\"\nconst fs = isNode ? await import(/*webpackIgnore: true*/ \"node:fs\") : undefined\n\n// ASCII character for enquiry.\nconst enq = String.fromCharCode(5)\n// ASCII character for unit separator.\nconst unit = String.fromCharCode(31)\n// On-disk root node format.\nconst root = unit + \"+0\" + unit + \"#\" + unit + '\"root' + unit\n\nconst fileSystem = opt => {\n  const dir = opt.file\n\n  if (isNode) {\n    if (!fs.existsSync(dir)) fs.mkdirSync(dir)\n    if (!fs.existsSync(dir + \"/!\")) fs.writeFileSync(dir + \"/!\", root)\n\n    return {\n      get: (file, cb) => {\n        fs.readFile(dir + \"/\" + file, (err, data) => {\n          if (err) {\n            if (err.code === \"ENOENT\") {\n              cb()\n              return\n            }\n\n            console.log(\"fs.readFile error:\", err)\n          }\n          if (data) data = data.toString()\n          cb(err, data)\n        })\n      },\n      put: (file, data, cb) => {\n        // Don't put tmp files under dir so that they're not listed.\n        var tmp = file + \".\" + utils.text.random(9) + \".tmp\"\n        fs.writeFile(tmp, data, err => {\n          if (err) {\n            console.log(\"fs.writeFile error:\", err)\n            cb(err)\n            return\n          }\n\n          fs.rename(tmp, dir + \"/\" + file, cb)\n        })\n      },\n      list: cb => {\n        fs.readdir(dir, (err, files) => {\n          if (err) {\n            console.log(\"fs.readdir error:\", err)\n            cb()\n            return\n          }\n\n          files.forEach(cb)\n          cb()\n        })\n      },\n    }\n  }\n\n  if (opt.indexedDB) {\n    let db\n    const o = indexedDB.open(dir, 1)\n    o.onupgradeneeded = event => {\n      event.target.result.createObjectStore(dir)\n    }\n    o.onerror = event => {\n      console.log(event)\n    }\n    o.onsuccess = () => {\n      db = o.result\n      // Create the root node if it doesn't exist.\n      if (db) {\n        const tx = db.transaction([dir], \"readonly\")\n        const req = tx.objectStore(dir).getKey(\"!\")\n        req.onerror = () => {\n          console.log(`error getting key ${dir}/!`)\n        }\n        req.onsuccess = () => {\n          if (!req.result) {\n            const tx = db.transaction([dir], \"readwrite\")\n            const req = tx.objectStore(dir).put(root, \"!\")\n            req.onerror = () => {\n              console.log(`error putting root on ${dir}/!`)\n            }\n          }\n        }\n      } else {\n        console.log(\"error indexedDB not available\")\n      }\n    }\n\n    return {\n      get: (file, cb) => {\n        const _get = (file, cb) => {\n          const tx = db.transaction([dir], \"readonly\")\n          const req = tx.objectStore(dir).get(file)\n          req.onerror = () => {\n            console.log(`error getting ${dir}/${file}`)\n          }\n          req.onsuccess = () => {\n            cb(null, req.result)\n          }\n        }\n        if (db) {\n          _get(file, cb)\n          return\n        }\n\n        let retry = 0\n        const interval = setInterval(() => {\n          if (db) {\n            clearInterval(interval)\n            _get(file, cb)\n            return\n          }\n\n          if (retry++ > 5) {\n            clearInterval(interval)\n            cb(\"error indexedDB not available\")\n          }\n        }, 1000)\n      },\n      put: (file, data, cb) => {\n        const _put = (file, data, cb) => {\n          const tx = db.transaction([dir], \"readwrite\")\n          const req = tx.objectStore(dir).put(data, file)\n          req.onerror = () => {\n            console.log(`error putting data on ${dir}/${file}`)\n          }\n          req.onsuccess = () => {\n            cb(null)\n          }\n        }\n        if (db) {\n          _put(file, data, cb)\n          return\n        }\n\n        let retry = 0\n        const interval = setInterval(() => {\n          if (db) {\n            clearInterval(interval)\n            _put(file, data, cb)\n            return\n          }\n\n          if (retry++ > 5) {\n            clearInterval(interval)\n            cb(\"error indexedDB not available\")\n          }\n        }, 1000)\n      },\n      list: cb => {\n        const _list = cb => {\n          const tx = db.transaction([dir], \"readonly\")\n          const req = tx.objectStore(dir).getAllKeys()\n          req.onerror = () => console.log(\"error getting keys for\", dir)\n          req.onsuccess = () => {\n            req.result.forEach(cb)\n            cb()\n          }\n        }\n        if (db) {\n          _list(cb)\n          return\n        }\n\n        let retry = 0\n        const interval = setInterval(() => {\n          if (db) {\n            clearInterval(interval)\n            _list(cb)\n            return\n          }\n\n          if (retry++ > 5) {\n            clearInterval(interval)\n            console.log(\"error indexedDB not available\")\n            cb()\n          }\n        }, 1000)\n      },\n    }\n  }\n\n  // No browser storage.\n  return {\n    get: (file, cb) => {\n      cb(null, root)\n    },\n    put: (file, data, cb) => {\n      cb(null)\n    },\n    list: cb => {\n      cb(\"!\")\n      cb()\n    },\n  }\n}\n\n// Store provides get and put methods that can access radisk.\nconst Store = opt => {\n  if (!utils.obj.is(opt)) opt = {}\n  opt.file = String(opt.file || \"radata\")\n  if (!opt.store) opt.store = fileSystem(opt)\n  const radisk = Radisk(opt)\n\n  return {\n    get: (lex, cb) => {\n      if (!lex || !utils.obj.is(lex)) {\n        cb(\"lex required\")\n        return\n      }\n      if (!lex[\"#\"]) {\n        cb(\"soul required in lex\")\n        return\n      }\n\n      var soul = lex[\"#\"]\n      var key = typeof lex[\".\"] === \"string\" ? lex[\".\"] : \"\"\n      var node\n      var signatures = {}\n      const each = (value, key) => {\n        if (!utils.match(lex[\".\"], key)) return\n\n        if (!node) node = {_: {\"#\": soul, \">\": {}}}\n        node[key] = value[0]\n        node._[\">\"][key] = value[1]\n        // If signature is present, store it in _[\"s\"]\n        if (value.length === 3 && value[2]) {\n          signatures[key] = value[2]\n        }\n      }\n\n      radisk(soul + enq + key, (err, value) => {\n        let graph\n        if (utils.obj.is(value)) {\n          Radix.map(value, each)\n          if (!node) each(value, key)\n          graph = {[soul]: node}\n        } else if (value) {\n          each(value, key)\n          graph = {[soul]: node}\n        }\n        // Only add _[\"s\"] if we found any signatures\n        if (graph && graph[soul] && Object.keys(signatures).length > 0) {\n          graph[soul]._[\"s\"] = signatures\n        }\n        cb(err, graph)\n      })\n    },\n    put: (graph, cb) => {\n      if (!graph) {\n        cb(\"graph required\")\n        return\n      }\n\n      let count = 0\n      let finished = false\n      const ack = err => {\n        count--\n        if (finished) return\n\n        if (err) {\n          finished = true\n          cb(err)\n          return\n        }\n\n        if (count === 0) {\n          finished = true\n          cb(null)\n        }\n      }\n\n      Object.keys(graph).forEach(soul => {\n        var node = graph[soul]\n        Object.keys(node).forEach(key => {\n          if (key === \"_\") return\n\n          count++\n          let value = node[key]\n          let state = node._[\">\"][key]\n          let sig = node._[\"s\"] && node._[\"s\"][key]\n          // Only pass signature if it exists, otherwise just [value, state]\n          let data = sig ? [value, state, sig] : [value, state]\n          radisk(soul + enq + key, data, ack)\n        })\n      })\n    },\n  }\n}\n\nexport default Store\n", "import Dup from \"./dup.js\"\nimport Get from \"./get.js\"\nimport Ham from \"./ham.js\"\nimport Store from \"./store.js\"\nimport * as utils from \"./utils.js\"\n\nconst isNode = typeof document === \"undefined\"\n\nconst wsModule = isNode ? await import(\"ws\") : undefined\n\nif (typeof globalThis.WebSocket === \"undefined\") {\n  globalThis.WebSocket = wsModule?.WebSocket\n}\n\n// Rate limiting with throttling\nconst createRateLimiter = isTestEnv => {\n  const clients = new Map()\n  const maxRequests = 1500 // requests per minute\n  const windowMs = 60000 // 1 minute window\n  const disconnectThreshold = 10 // Disconnect after 10 violations\n  let cleanupInterval = null\n\n  const cleanup = () => {\n    const now = Date.now()\n    for (const [clientId, data] of clients.entries()) {\n      if (now - data.lastCleanup > windowMs) {\n        data.requests = []\n        data.lastCleanup = now\n      }\n      data.requests = data.requests.filter(time => now - time < windowMs)\n      // Reset throttle counts periodically\n      if (now - data.lastCleanup > windowMs * 10) {\n        data.throttleCount = 0\n      }\n    }\n  }\n\n  if (!isTestEnv) {\n    cleanupInterval = setInterval(cleanup, windowMs / 4)\n  }\n\n  return {\n    getDelay: clientId => {\n      const now = Date.now()\n      const client = clients.get(clientId) || {\n        requests: [],\n        lastCleanup: now,\n        throttleCount: 0,\n      }\n\n      // Filter old requests\n      client.requests = client.requests.filter(time => now - time < windowMs)\n\n      if (client.requests.length >= maxRequests) {\n        // Calculate delay based on oldest request that will expire\n        const oldestRequest = Math.min(...client.requests)\n        const delay = windowMs - (now - oldestRequest)\n        // Increment throttle count and update client data\n        client.throttleCount = (client.throttleCount || 0) + 1\n        clients.set(clientId, client)\n        return Math.max(0, delay)\n      }\n\n      // No delay needed, track this request\n      client.requests.push(now)\n      clients.set(clientId, client)\n      return 0\n    },\n\n    getRemainingRequests: clientId => {\n      const client = clients.get(clientId)\n      if (!client) return maxRequests\n\n      const now = Date.now()\n      const validRequests = client.requests.filter(\n        time => now - time < windowMs,\n      )\n      return Math.max(0, maxRequests - validRequests.length)\n    },\n\n    getThrottleCount: clientId => {\n      const client = clients.get(clientId)\n      return client ? client.throttleCount || 0 : 0\n    },\n\n    shouldDisconnect: clientId => {\n      const client = clients.get(clientId)\n      if (!client) return false\n      return client.throttleCount >= disconnectThreshold\n    },\n\n    destroy: () => {\n      if (cleanupInterval) {\n        clearInterval(cleanupInterval)\n        cleanupInterval = null\n      }\n      clients.clear()\n    },\n  }\n}\n\n// Safe JSON parser with size limit\nconst safeJSONParse = (data, maxSize = 1024 * 1024) => {\n  try {\n    if (typeof data === \"string\" && data.length > maxSize) {\n      throw new Error(\"Message too large\")\n    }\n    return {success: true, data: JSON.parse(data)}\n  } catch (error) {\n    return {success: false, error: error.message}\n  }\n}\n\n// Message size validator\nconst validateMessage = (data, maxSize = 1024 * 1024) => {\n  // 1MB default\n  if (typeof data === \"string\" && data.length > maxSize) {\n    return {valid: false, error: \"Message too large\"}\n  }\n  if (Buffer.isBuffer(data) && data.length > maxSize) {\n    return {valid: false, error: \"Message too large\"}\n  }\n  return {valid: true}\n}\n\n// Connection manager to limit concurrent connections\nconst createConnectionManager = (maxConnections = 1000) => {\n  const connections = new Set()\n\n  return {\n    add: ws => {\n      if (connections.size >= maxConnections) {\n        return false\n      }\n      connections.add(ws)\n\n      // Clean up on close\n      const originalClose = ws.close\n      ws.close = (...args) => {\n        connections.delete(ws)\n        return originalClose.apply(ws, args)\n      }\n\n      return true\n    },\n\n    remove: ws => {\n      connections.delete(ws)\n    },\n\n    count: () => connections.size,\n\n    isFull: () => connections.size >= maxConnections,\n  }\n}\n\n// Enhanced retry mechanism with exponential backoff\nconst createRetryHandler = (maxRetries = 5) => {\n  let retryCount = 0\n\n  return {\n    shouldRetry: () => retryCount < maxRetries,\n    getDelay: () => Math.min(1000 * Math.pow(2, retryCount), 30000), // Max 30s\n    increment: () => retryCount++,\n    reset: () => (retryCount = 0),\n  }\n}\n\n// Wire starts a websocket client or server and returns get and put methods\n// for access to the wire spec and storage.\nconst Wire = opt => {\n  const dup = Dup(opt.maxAge)\n  const store = Store(opt)\n  const graph = {}\n  const queue = {}\n  const listen = {}\n\n  // Track references we want but don't have yet\n  const pendingReferences = new Set()\n\n  // Track pending timeouts that should start when message is sent\n  const pendingTimeouts = new Map()\n\n  // Helper to check if we have a soul in memory or storage\n  const hasSoul = async soul => {\n    if (graph[soul]) return true\n    return new Promise(resolve => {\n      store.get({\"#\": soul}, (err, data) => {\n        resolve(!err && data && data[soul])\n      })\n    })\n  }\n\n  // Initialize rate limiting and connection management\n  // Check if test environment (mock-socket usage)\n  const isTestEnv = opt.wss && opt.wss.constructor.name === \"Server\"\n  const rateLimiter = createRateLimiter(isTestEnv)\n  const connectionManager = createConnectionManager(opt.maxConnections || 1000)\n\n  // The check function is required because user data must provide a public key\n  // so that it can be verified. The public key might verify the provided\n  // signature but not actually match the user under which the data is being\n  // stored. To avoid this, the current data on a soul needs to be checked to\n  // make sure the stored public key matches the one provided with the update.\n  const check = async (data, send, cb) => {\n    for (const soul of Object.keys(data)) {\n      const msg = await new Promise(res => {\n        getWithCallback({\"#\": soul}, res, send)\n      })\n      if (msg.err) {\n        if (cb) cb(msg.err)\n        return false\n      }\n\n      const node = data[soul]\n      const key = utils.userPublicKey\n      // If there is no current node then the data is ok to write without\n      // matching public keys, as the provided soul also needs a rel on the\n      // parent node which then also requires checking. Otherwise publc keys\n      // need to match for existing data.\n      if (!msg.put || !msg.put[soul] || msg.put[soul][key] === node[key]) {\n        continue\n      }\n\n      // If a soul exists but does not have a public key, then one should not be\n      // added because the node is not user data. The above check fails in this\n      // case if a public key is provided. Note that this is only an error case\n      // if called via the API, which is when a callback is provided here.\n      // (The wire spec can fetch and put data on the wire without a signature\n      // or public key and this can be ignored.)\n      if (cb) {\n        cb(`error in wire check public key does not match for soul: ${soul}`)\n      }\n      return false\n    }\n\n    return true\n  }\n\n  const get = (msg, send) => {\n    const ack = Get(msg.get, graph)\n    if (ack) {\n      send(\n        JSON.stringify({\n          \"#\": dup.track(utils.text.random(9)),\n          \"@\": msg[\"#\"],\n          put: ack,\n        }),\n      )\n    } else {\n      store.get(msg.get, (err, ack) => {\n        send(\n          JSON.stringify({\n            \"#\": dup.track(utils.text.random(9)),\n            \"@\": msg[\"#\"],\n            put: ack,\n            err: err,\n          }),\n        )\n      })\n    }\n  }\n\n  const put = async (msg, send) => {\n    // Store updates returned from Ham.mix and defer updates if required.\n    const update = await Ham.mix(msg.put, graph, opt.secure, listen)\n    if (Object.keys(update.now).length === 0) {\n      // No updates to store, check deferred.\n      if (Object.keys(update.defer).length !== 0) {\n        setTimeout(\n          () => put({put: update.defer, \"#\": msg[\"#\"]}, send),\n          update.wait,\n        )\n      }\n      return\n    }\n\n    if (!(await check(update.now, send))) return\n\n    store.put(update.now, err => {\n      send(\n        JSON.stringify({\n          \"#\": dup.track(utils.text.random(9)),\n          \"@\": msg[\"#\"],\n          err: err,\n        }),\n      )\n    })\n\n    if (Object.keys(update.defer).length !== 0) {\n      setTimeout(\n        () => put({put: update.defer, \"#\": msg[\"#\"]}, send),\n        update.wait,\n      )\n    }\n  }\n\n  const getWithCallback = (lex, cb, send, _opt) => {\n    if (!cb) return\n\n    if (!utils.obj.is(_opt)) _opt = {}\n\n    const ack = Get(lex, graph)\n    const track = utils.text.random(9)\n    // Request the whole node in secure mode for verification.\n    const request = JSON.stringify({\n      \"#\": dup.track(track),\n      get: opt.secure ? {\"#\": lex[\"#\"]} : lex,\n    })\n\n    if (ack) {\n      // Also send request on the wire to check for updates.\n      const sendResult = send(request)\n      if (sendResult && sendResult.err) {\n        cb({err: sendResult.err})\n        return\n      }\n      cb({put: ack})\n      return\n    }\n\n    store.get(lex, (err, ack) => {\n      if (ack) {\n        // Also send request on the wire to check for updates.\n        const sendResult = send(request)\n        if (sendResult && sendResult.err) {\n          cb({err: sendResult.err})\n          return\n        }\n        cb({put: ack, err: err})\n        return\n      }\n\n      if (err) console.log(err)\n\n      queue[track] = cb\n\n      // Store timeout config to start after message is sent from queue\n      pendingTimeouts.set(track, {\n        lex: lex,\n        wait: _opt.wait || 100,\n      })\n\n      const sendResult = send(request)\n      if (sendResult && sendResult.err) {\n        cb({err: sendResult.err})\n        delete queue[track]\n        pendingTimeouts.delete(track)\n        return\n      }\n    })\n  }\n\n  const api = send => {\n    return {\n      get: (lex, cb, _opt) => {\n        // Mark requested soul as something we want to store\n        if (lex && lex[\"#\"]) {\n          pendingReferences.add(lex[\"#\"])\n        }\n        getWithCallback(lex, cb, send, _opt)\n      },\n      put: async (data, cb) => {\n        // Deferred updates are only stored using wire spec, they're ignored\n        // here using the api. This is ok because correct timestamps should be\n        // used whereas wire spec needs to handle clock skew for updates\n        // across the network.\n        const update = await Ham.mix(data, graph, opt.secure, listen)\n        if (Object.keys(update.now).length === 0) {\n          // No updates, still respond to callback.\n          if (cb) cb(null)\n          return\n        }\n\n        if (!(await check(update.now, send, cb))) return\n\n        // Seed pendingReferences with any new references from API calls\n        for (const [soul, node] of Object.entries(update.now)) {\n          if (node && typeof node === \"object\") {\n            for (const [key, value] of Object.entries(node)) {\n              const soulId = utils.rel.is(value)\n              if (soulId) {\n                // Add referenced soul to pending list\n                pendingReferences.add(soulId)\n              }\n            }\n          }\n        }\n\n        store.put(update.now, cb)\n\n        // Always put data on the wire spec even if no local update needed\n        const sendResult = send(\n          JSON.stringify({\n            \"#\": dup.track(utils.text.random(9)),\n            put: data,\n          }),\n        )\n        // Handle queue overflow error.\n        if (sendResult && sendResult.err) {\n          if (cb) cb(sendResult.err)\n          return\n        }\n      },\n      on: (lex, cb, _get, _opt) => {\n        const soul = lex && lex[\"#\"]\n        if (!soul || !cb) return\n\n        if (listen[soul]) {\n          listen[soul].push({\".\": lex[\".\"], cb: cb})\n        } else {\n          listen[soul] = [{\".\": lex[\".\"], cb: cb}]\n        }\n        if (_get) getWithCallback(lex, cb, send, _opt)\n      },\n      off: (lex, cb) => {\n        const soul = lex && lex[\"#\"]\n        if (!soul || !listen[soul]) return\n\n        if (cb) {\n          const found = listen[soul].find(l => l.cb === cb)\n          if (found) {\n            listen[soul].splice(listen[soul].indexOf(found), 1)\n          }\n        } else {\n          // Remove all callbacks when none provided.\n          delete listen[soul]\n        }\n      },\n    }\n  }\n\n  if (isNode) {\n    let wss = opt.wss\n    // Node's websocket server provides clients as an array, whereas\n    // mock-sockets provides clients as a function that returns an array.\n    let clients = () => wss.clients()\n    if (!wss) {\n      const config = opt.server\n        ? {server: opt.server}\n        : {port: opt.port || 8765}\n      wss = new wsModule.WebSocketServer(config)\n      clients = () => wss.clients\n    }\n\n    const send = (data, isBinary) => {\n      // Start timeout for this message now that it's being sent\n      const msg = JSON.parse(data)\n      const trackId = msg[\"#\"]\n      if (trackId && pendingTimeouts.has(trackId)) {\n        const timeoutConfig = pendingTimeouts.get(trackId)\n        pendingTimeouts.delete(trackId)\n\n        // Respond to callback with null if no response.\n        timeoutConfig.timeoutId = setTimeout(() => {\n          const cb = queue[trackId]\n          if (cb) {\n            const id = timeoutConfig.lex[\"#\"]\n            const ack = {[id]: null}\n            if (typeof timeoutConfig.lex[\".\"] === \"string\") {\n              ack[id] = {[timeoutConfig.lex[\".\"]]: null}\n            }\n            cb({put: ack})\n            delete queue[trackId]\n          }\n        }, timeoutConfig.wait)\n      }\n\n      clients().forEach(client => {\n        if (client && client.readyState === WebSocket.OPEN) {\n          client.send(data, {binary: isBinary})\n        } else {\n          const retryHandler = client._retryHandler || createRetryHandler()\n          client._retryHandler = retryHandler\n\n          if (retryHandler.shouldRetry()) {\n            const delay = retryHandler.getDelay()\n            retryHandler.increment()\n\n            setTimeout(() => {\n              if (client && client.readyState === WebSocket.OPEN) {\n                retryHandler.reset()\n                client.send(data, {binary: isBinary})\n              }\n            }, delay)\n          }\n        }\n      })\n    }\n    wss.on(\"connection\", ws => {\n      // Check connection limit\n      if (!connectionManager.add(ws)) {\n        console.log(\"Connection limit reached, rejecting connection\")\n        ws.close(1013, \"Connection limit reached - try again later\")\n        return\n      }\n\n      // Generate unique client ID for rate limiting\n      const clientId = utils.text.random(9)\n      console.log(`New WebSocket client connected: ${clientId}`)\n\n      ws.on(\"error\", error => {\n        console.log(\"WebSocket error:\", error)\n        connectionManager.remove(ws)\n      })\n\n      ws.on(\"close\", () => {\n        console.log(`WebSocket client disconnected: ${clientId}`)\n        connectionManager.remove(ws)\n      })\n\n      ws.on(\"message\", (data, isBinary) => {\n        // Validate message size\n        const validation = validateMessage(data, opt.maxMessageSize)\n        if (!validation.valid) {\n          console.warn(`Invalid message: ${validation.error}`)\n          ws.send(JSON.stringify({error: validation.error}))\n          return\n        }\n\n        // Safe JSON parsing\n        const parseResult = safeJSONParse(data, opt.maxMessageSize)\n        if (!parseResult.success) {\n          console.warn(`JSON parse error: ${parseResult.error}`)\n          ws.send(JSON.stringify({error: \"Invalid JSON\"}))\n          return\n        }\n\n        const msg = parseResult.data\n        if (dup.check(msg[\"#\"])) return\n\n        // Check rate limit and get delay\n        const delay = rateLimiter.getDelay(clientId)\n        // Log rate limiting activity and enforce stricter limits\n        if (delay > 0) {\n          const throttleCount = rateLimiter.getThrottleCount(clientId)\n          console.log(\n            `Client ${clientId}: rate limit exceeded, delay would be ${delay}ms, dropping message (throttle count: ${throttleCount})`,\n          )\n          // Check if we should disconnect the bad actor\n          if (rateLimiter.shouldDisconnect(clientId)) {\n            console.log(\n              `Client ${clientId}: Disconnecting after ${throttleCount} throttle violations`,\n            )\n            ws.close(1008, \"Rate limit violations\")\n            return\n          }\n\n          // Send throttle warning back to client instead of processing\n          ws.send(\n            JSON.stringify({\n              \"#\": dup.track(utils.text.random(9)),\n              \"@\": msg[\"#\"],\n              err: `Rate limit exceeded. Slow down requests. Wait ${Math.ceil(delay / 1000)}s`,\n              throttle: delay,\n            }),\n          )\n          return\n        }\n\n        const processMessage = () => {\n          dup.track(msg[\"#\"])\n\n          if (msg.get) get(msg, send)\n          if (msg.put) put(msg, send)\n          send(data, isBinary)\n\n          const id = msg[\"@\"]\n          const cb = queue[id]\n          if (cb) {\n            delete msg[\"#\"]\n            delete msg[\"@\"]\n            cb(msg)\n\n            delete queue[id]\n          }\n        }\n\n        if (delay > 0) {\n          // Throttle the client by delaying message processing\n          setTimeout(processMessage, delay)\n        } else {\n          // Process immediately\n          processMessage()\n        }\n      })\n    })\n    return api(send)\n  }\n\n  // Browser logic.\n  const peers = []\n  // Client-side throttling state\n  let clientThrottled = false\n  let throttleUntil = 0\n  let messageQueue = []\n  let queueProcessor = null\n  const maxQueueLength = opt.maxQueueLength || 10000\n\n  const processQueue = () => {\n    if (messageQueue.length === 0) {\n      queueProcessor = null\n      return\n    }\n\n    const now = Date.now()\n    if (clientThrottled && now < throttleUntil) {\n      // Still throttled, schedule next queue check\n      queueProcessor = setTimeout(\n        processQueue,\n        Math.min(1000, throttleUntil - now),\n      )\n      return\n    }\n\n    // Throttle period ended, resume processing\n    if (clientThrottled && now >= throttleUntil) {\n      console.log(`Throttle period ended, resuming queue processing`)\n      clientThrottled = false\n      throttleUntil = 0\n    }\n\n    // Process next message in queue\n    const data = messageQueue[0]\n    const sent = sendToPeers(data)\n\n    if (sent) {\n      // Only remove from queue if successfully sent\n      messageQueue.shift()\n\n      // Start timeout for this message now that it's been sent\n      const msg = JSON.parse(data)\n      const trackId = msg[\"#\"]\n      if (trackId && pendingTimeouts.has(trackId)) {\n        const timeoutConfig = pendingTimeouts.get(trackId)\n        pendingTimeouts.delete(trackId)\n\n        // Respond to callback with null if no response.\n        timeoutConfig.timeoutId = setTimeout(() => {\n          const cb = queue[trackId]\n          if (cb) {\n            const id = timeoutConfig.lex[\"#\"]\n            const ack = {[id]: null}\n            if (typeof timeoutConfig.lex[\".\"] === \"string\") {\n              ack[id] = {[timeoutConfig.lex[\".\"]]: null}\n            }\n            cb({put: ack})\n            delete queue[trackId]\n          }\n        }, timeoutConfig.wait)\n      }\n    }\n\n    // Schedule processing of next message if queue not empty\n    if (messageQueue.length > 0) {\n      // Add delay between messages to respect rate limit\n      queueProcessor = setTimeout(processQueue, 50)\n    } else {\n      queueProcessor = null\n    }\n  }\n\n  const sendToPeers = data => {\n    let sentToAtLeastOne = false\n    peers.forEach(peer => {\n      if (peer && peer.readyState === WebSocket.OPEN) {\n        peer.send(data)\n        sentToAtLeastOne = true\n      } else {\n        const retryHandler = peer._retryHandler || createRetryHandler()\n        peer._retryHandler = retryHandler\n\n        if (retryHandler.shouldRetry()) {\n          const delay = retryHandler.getDelay()\n          retryHandler.increment()\n\n          setTimeout(() => {\n            if (peer && peer.readyState === WebSocket.OPEN) {\n              retryHandler.reset()\n              peer.send(data)\n            }\n          }, delay)\n        }\n      }\n    })\n    return sentToAtLeastOne\n  }\n\n  const send = data => {\n    if (messageQueue.length >= maxQueueLength) {\n      return {\n        err: `Message queue exceeded maximum length (${maxQueueLength}). Update query logic to request less data.`,\n        queueLength: messageQueue.length,\n        maxQueueLength: maxQueueLength,\n      }\n    }\n\n    messageQueue.push(data)\n    // Start queue processor if not already running\n    if (!queueProcessor) {\n      queueProcessor = setTimeout(processQueue, 50)\n    }\n  }\n  if (!(opt.peers instanceof Array)) {\n    opt.peers = [`ws://localhost:${opt.port || 8765}`]\n  }\n  opt.peers.forEach(peer => {\n    const start = () => {\n      let ws = new WebSocket(peer)\n      peers.push(ws)\n      const retryHandler = createRetryHandler()\n\n      ws.onclose = c => {\n        if (peers.indexOf(ws) !== -1) {\n          peers.splice(peers.indexOf(ws), 1)\n        }\n        ws = null\n\n        if (retryHandler.shouldRetry()) {\n          const delay = retryHandler.getDelay()\n          retryHandler.increment()\n          setTimeout(start, delay)\n        }\n      }\n\n      ws.onopen = () => {\n        retryHandler.reset()\n      }\n\n      ws.onerror = e => {\n        console.log(e)\n      }\n      ws.onmessage = async m => {\n        const msg = JSON.parse(m.data)\n        if (dup.check(msg[\"#\"])) return\n\n        // Handle throttle messages from server\n        if (msg.throttle && msg.err) {\n          console.log(`Server throttling: ${msg.err}`)\n          clientThrottled = true\n          throttleUntil = Date.now() + msg.throttle\n          return\n        }\n\n        dup.track(msg[\"#\"])\n        if (msg.get) get(msg, send)\n        if (msg.put) {\n          // Handle selective storage for client WebSocket messages\n          const filteredPut = {}\n          for (const [soul, node] of Object.entries(msg.put)) {\n            let shouldStore = false\n            // Case 1: We already have this soul - always update\n            if (await hasSoul(soul)) {\n              shouldStore = true\n              // Check if this update adds new references\n              if (node && typeof node === \"object\") {\n                for (const [key, value] of Object.entries(node)) {\n                  const soulId = utils.rel.is(value)\n                  if (soulId) {\n                    // Add referenced soul to pending list\n                    pendingReferences.add(soulId)\n                  }\n                }\n              }\n            }\n            // Case 2: This soul was referenced by something we have\n            if (pendingReferences.has(soul)) {\n              shouldStore = true\n              pendingReferences.delete(soul) // Got it, remove from pending\n            }\n            if (shouldStore) {\n              filteredPut[soul] = node\n            }\n          }\n          // Store filtered data if any\n          if (Object.keys(filteredPut).length > 0) {\n            // Create filtered message for Ham.mix with original message ID\n            const filteredMsg = {put: filteredPut, \"#\": msg[\"#\"]}\n            put(filteredMsg, send)\n          }\n        }\n\n        const id = msg[\"@\"]\n        const cb = queue[id]\n        if (cb) {\n          delete msg[\"#\"]\n          delete msg[\"@\"]\n          cb(msg)\n\n          delete queue[id]\n        }\n      }\n    }\n    start()\n  })\n\n  return api(send)\n}\n\nexport default Wire\n", "import * as utils from \"./utils.js\"\nimport Wire from \"./wire.js\"\nimport SEA from \"./sea.js\"\nimport {userPublicKey, userSignature} from \"./utils.js\"\n\nconst User = (opt, wire) => {\n  if (!wire) wire = Wire(opt)\n  let pubs = []\n  let creating = false\n  let authing = false\n  let retries = 0\n\n  const auth = (username, password, newPassword, ack) => {\n    const retry = username => {\n      retries++\n      auth(username, password, newPassword, ack)\n    }\n    const done = err => {\n      pubs = []\n      retries = 0\n      authing = false\n      ack(err)\n    }\n    const next = () => {\n      if (pubs.length === 0) {\n        done(\"Wrong username or password\")\n        return\n      }\n\n      const pub = pubs.shift()\n      wire.get(\n        {\"#\": pub},\n        async msg => {\n          if (msg.err) {\n            done(`error getting ${pub}: ${msg.err}`)\n            return\n          }\n\n          const data = msg.put && msg.put[pub]\n          if (!data || !data.auth) return next()\n\n          const auth = JSON.parse(data.auth)\n          const work = await SEA.work(password, auth.salt)\n          const dec = await SEA.decrypt(auth.enc, work)\n          if (!dec) return next()\n\n          user.is = {\n            username: username,\n            pub: data.pub,\n            epub: data.epub,\n            priv: dec.priv,\n            epriv: dec.epriv,\n          }\n          if (newPassword !== \"\") {\n            // Encrypt private key using new password and a new salt.\n            const salt = utils.text.random(64)\n            const work = await SEA.work(newPassword, salt)\n            const enc = await SEA.encrypt(dec, work)\n            // Only update the auth property with the new password encryption.\n            const update = {\n              auth: JSON.stringify({enc: enc, salt: salt}),\n            }\n            const propertySignatures = await SEA.signProperties(update, user.is)\n            const graph = utils.graph(pub, update, propertySignatures, data.pub)\n            wire.put(graph, err => {\n              if (err) {\n                done(`error putting ${update} on ${pub}: ${err}`)\n              } else {\n                done(null)\n              }\n            })\n            return\n          }\n\n          // TODO: Remove this migration once all peers have updated to the new\n          // version and have received per-property signatures. This temporarily\n          // broadcasts signed data on every login to ensure new peers can\n          // persist it.\n          const migrationData = {}\n          for (const key of Object.keys(data)) {\n            if (key !== \"_\" && key !== userPublicKey && key !== userSignature) {\n              migrationData[key] = data[key]\n            }\n          }\n          // Sign each property individually\n          const propertySignatures = await SEA.signProperties(\n            migrationData,\n            user.is,\n          )\n          const graph = utils.graph(\n            pub,\n            migrationData,\n            propertySignatures,\n            data.pub,\n          )\n          wire.put(graph, err => {\n            if (err) {\n              // Log migration error but don't fail authentication\n              console.log(\n                `warning: failed to migrate signatures on login: ${err}`,\n              )\n            }\n            done(null)\n          })\n        },\n        {wait: 5000},\n      )\n    }\n\n    if (retries > 9) {\n      done(\"Wrong username or password\")\n      return\n    }\n\n    const soul = \"~@\" + username\n    wire.get(\n      {\"#\": soul},\n      async msg => {\n        if (msg.err) {\n          done(`error getting ${soul}: ${msg.err}`)\n          return\n        }\n\n        const data = msg.put && msg.put[soul]\n        if (!data) return retry(username)\n\n        delete msg.put[soul]._\n        // Usernames aren't guaranteed to be unique, so store the list and then\n        // try each of them until one is successful with the given password.\n        pubs = Object.keys(data)\n        next()\n      },\n      {wait: 5000},\n    )\n  }\n\n  const user = {\n    create: (username, password, cb) => {\n      const ack = err => {\n        if (cb) cb(err)\n        else console.log(err)\n      }\n\n      if (creating) {\n        ack(\"User is already being created\")\n        return\n      }\n\n      if (username === \"\") {\n        ack(\"Please provide a username\")\n        return\n      }\n\n      if (password === \"\") {\n        ack(\"Please provide a password\")\n        return\n      }\n\n      creating = true\n\n      const soul = \"~@\" + username\n      wire.get(\n        {\"#\": soul},\n        async msg => {\n          if (msg.err) {\n            creating = false\n            ack(`error getting ${soul}: ${msg.err}`)\n            return\n          }\n\n          if (msg.put && msg.put[soul]) {\n            creating = false\n            ack(\"Username already exists\")\n            return\n          }\n\n          const salt = utils.text.random(64)\n          const work = await SEA.work(password, salt)\n          const pair = await SEA.pair()\n          const priv = {priv: pair.priv, epriv: pair.epriv}\n          const enc = await SEA.encrypt(priv, work)\n          const data = {\n            username: username,\n            pub: pair.pub,\n            epub: pair.epub,\n            auth: JSON.stringify({enc: enc, salt: salt}),\n          }\n\n          const pub = \"~\" + pair.pub\n          // Sign each property individually for new account\n          const propertySignatures = await SEA.signProperties(data, pair)\n          const graph = utils.graph(pub, data, propertySignatures, pair.pub)\n          wire.put(graph, err => {\n            creating = false\n            if (err) {\n              ack(`error putting ${data} on ${pub}: ${err}`)\n              return\n            }\n\n            const rel = {[pub]: {\"#\": pub}}\n            wire.put(utils.graph(soul, rel), err => {\n              if (err) {\n                ack(`error putting ${rel} on ${soul}: ${err}`)\n                return\n              }\n\n              // Return null on success.\n              if (cb) cb(null)\n            })\n          })\n        },\n        {wait: 5000},\n      )\n    },\n    auth: (username, password, cb) => {\n      const ack = err => {\n        if (cb) cb(err)\n        else if (err) console.log(err)\n      }\n\n      if (authing) {\n        ack(\"User is already authenticating\")\n        return\n      }\n\n      user.is = null\n\n      if (username === \"\") {\n        ack(\"Please provide a username\")\n        return\n      }\n\n      if (password === \"\") {\n        ack(\"Please provide a password\")\n        return\n      }\n\n      authing = true\n      auth(username, password, \"\", ack)\n    },\n    change: (username, password, newPassword, cb) => {\n      const ack = err => {\n        if (cb) cb(err)\n        else if (err) console.log(err)\n      }\n\n      if (authing) {\n        ack(\"User is already authenticating\")\n        return\n      }\n\n      user.is = null\n\n      if (username === \"\") {\n        ack(\"Please provide a username\")\n        return\n      }\n\n      if (password === \"\") {\n        ack(\"Please provide a password\")\n        return\n      }\n\n      if (newPassword === \"\") {\n        ack(\"Please provide a new password\")\n        return\n      }\n\n      authing = true\n      auth(username, password, newPassword, ack)\n    },\n    store: localStorage => {\n      if (!user.is) {\n        console.log(\"Please authenticate before calling store\")\n        return\n      }\n\n      if (localStorage) {\n        if (typeof globalThis.localStorage !== \"undefined\") {\n          globalThis.localStorage.setItem(\"user.is\", JSON.stringify(user.is))\n        }\n        if (typeof globalThis.sessionStorage !== \"undefined\") {\n          globalThis.sessionStorage.removeItem(\"user.is\")\n        }\n        return\n      }\n\n      if (typeof globalThis.sessionStorage !== \"undefined\") {\n        globalThis.sessionStorage.setItem(\"user.is\", JSON.stringify(user.is))\n      }\n      if (typeof globalThis.localStorage !== \"undefined\") {\n        globalThis.localStorage.removeItem(\"user.is\")\n      }\n    },\n    recall: () => {\n      if (typeof globalThis.localStorage !== \"undefined\") {\n        const is = globalThis.localStorage.getItem(\"user.is\")\n        if (is) {\n          user.is = JSON.parse(is)\n          return\n        }\n      }\n\n      if (typeof globalThis.sessionStorage !== \"undefined\") {\n        const is = globalThis.sessionStorage.getItem(\"user.is\")\n        if (is) {\n          user.is = JSON.parse(is)\n        }\n      }\n    },\n    leave: () => {\n      user.is = null\n      if (typeof globalThis.localStorage !== \"undefined\") {\n        globalThis.localStorage.removeItem(\"user.is\")\n      }\n      if (typeof globalThis.sessionStorage !== \"undefined\") {\n        globalThis.sessionStorage.removeItem(\"user.is\")\n      }\n    },\n    delete: (username, password, cb) => {\n      const ack = err => {\n        if (cb) cb(err)\n        else console.log(err)\n      }\n\n      if (authing) {\n        ack(\"User is already authenticating\")\n        return\n      }\n\n      if (username === \"\") {\n        ack(\"Please provide a username\")\n        return\n      }\n\n      if (password === \"\") {\n        ack(\"Please provide a password\")\n        return\n      }\n\n      authing = true\n      auth(username, password, \"\", async err => {\n        if (err) {\n          ack(err)\n          return\n        }\n\n        const data = {username: null, pub: null, epub: null, auth: null}\n        // Sign each property individually for account deletion\n        const propertySignatures = await SEA.signProperties(data, user.is)\n        const pub = \"~\" + user.is.pub\n        const graph = utils.graph(pub, data, propertySignatures, user.is.pub)\n        wire.put(graph, err => {\n          if (err) {\n            ack(`error putting null on ${pub}: ${err}`)\n            return\n          }\n\n          user.is = null\n          // Return null on success. Note currently not updating ~@username,\n          // not sure if allowing username re-user is a good idea anyway?\n          if (cb) cb(null)\n        })\n      })\n    },\n  }\n  return user\n}\n\nexport default User\n", "import * as utils from \"./utils.js\"\nimport Wire from \"./wire.js\"\nimport User from \"./user.js\"\nimport SEA from \"./sea.js\"\n\nconst Holster = opt => {\n  if (typeof opt === \"string\") opt = {peers: [opt]}\n  else if (opt instanceof Array) opt = {peers: opt}\n  else if (!utils.obj.is(opt)) opt = {}\n\n  const wire = Wire(opt)\n  const user = User(null, wire)\n  // Map callbacks since the user's callback is not passed to wire.on.\n  const map = new Map()\n  // Allow concurrent calls to the api by storing each context.\n  const allctx = new Map()\n\n  const ok = data => {\n    return (\n      data === null ||\n      data === true ||\n      data === false ||\n      typeof data === \"string\" ||\n      utils.rel.is(data) ||\n      utils.num.is(data)\n    )\n  }\n\n  // check returns true if data is ok to add to a graph, an error string if\n  // the data can't be converted, and the keys on the data object otherwise.\n  const check = data => {\n    if (ok(data)) return true\n\n    if (utils.obj.is(data)) {\n      const keys = []\n      for (const [key, value] of Object.entries(data)) {\n        if (key === \"_\") {\n          return \"error underscore cannot be used as a property name\"\n        }\n        if (utils.obj.is(value) || ok(value)) {\n          keys.push(key)\n          continue\n        }\n        if (typeof value === \"undefined\") {\n          return `error undefined ${key} cannot be converted to a graph`\n        }\n        const error = JSON.stringify({[key]: value})\n        return `error ${error} cannot be converted to a graph`\n      }\n      if (keys.length !== 0) return keys\n    }\n    const error = JSON.stringify(data)\n    return `error ${error} cannot be converted to a graph`\n  }\n\n  const api = ctxid => {\n    const get = (lex, soul, ack, _opt) => {\n      wire.get(\n        utils.obj.put(lex, \"#\", soul),\n        async msg => {\n          if (msg.err) console.log(msg.err)\n          if (msg.put && msg.put[soul]) {\n            delete msg.put[soul]._\n            delete msg.put[soul][utils.userPublicKey]\n            delete msg.put[soul][utils.userSignature]\n            // Resolve any rels on the node before returning to the user.\n            for (const key of Object.keys(msg.put[soul])) {\n              const id = utils.rel.is(msg.put[soul][key])\n              if (id) {\n                // Due to message queuing, the related node might not be available yet\n                // Retry with delays if we get null\n                const attemptRead = async (retries = 0) => {\n                  const data = await new Promise(res => {\n                    const _ctxid = utils.text.random()\n                    allctx.set(_ctxid, {chain: [{item: null, soul: id}]})\n                    api(_ctxid).next(null, res, _opt)\n                  })\n                  if (data !== null || retries >= 5) {\n                    return data\n                  }\n                  // Data not ready, retry after delay\n                  await new Promise(resolve => setTimeout(resolve, 50))\n                  return attemptRead(retries + 1)\n                }\n                msg.put[soul][key] = await attemptRead()\n              }\n            }\n            ack(msg.put[soul])\n          } else {\n            // No data callback.\n            ack(null)\n          }\n        },\n        _opt,\n      )\n    }\n\n    const graph = async (soul, data, userctx, cb) => {\n      if (userctx) {\n        // Sign each property individually\n        const propertySignatures = await SEA.signProperties(data, userctx)\n        return utils.graph(soul, data, propertySignatures, userctx.pub)\n      }\n\n      if (opt.secure) {\n        if (!cb) cb = console.log\n        cb(`error putting data on ${soul}: user required in secure mode`)\n        return null\n      }\n\n      return utils.graph(soul, data)\n    }\n\n    // done takes a context id and returns a new callback function so that the\n    // callback is not overwritten by simultaneous requests.\n    const done = ctxid => {\n      return data => {\n        const ctx = allctx.get(ctxid)\n        if (ctx && typeof ctx.cb !== \"undefined\") {\n          // Use a timeout so that the context can be removed before data is\n          // returned to the callback (allows nested get calls).\n          setTimeout(() => ctx.cb(data), 1)\n        } else if (data) {\n          console.log(\"error no callback for data\", data, \"ctx\", ctx)\n        }\n        // A context updated by \"on\" should only be removed by \"off\".\n        if (ctx && !ctx.on) allctx.delete(ctxid)\n      }\n    }\n\n    const resolve = (request, cb) => {\n      if (!request) {\n        console.log(\"error resolve request parameter required\")\n        return\n      }\n\n      const get = typeof request.get !== \"undefined\"\n      const put = typeof request.put !== \"undefined\"\n      const on = typeof request.on !== \"undefined\"\n      const off = typeof request.off !== \"undefined\"\n\n      let found = false\n      const ctx = allctx.get(ctxid)\n      for (var i = 1; i < ctx.chain.length; i++) {\n        if (ctx.chain[i].soul !== null) continue\n\n        found = true\n        break\n      }\n\n      if (found) {\n        // Found a soul that needs resolving, need the previous context\n        // (ie the parent node) to find a soul relation for it.\n        const {item, soul} = ctx.chain[i - 1]\n        wire.get(\n          {\"#\": soul, \".\": item},\n          async msg => {\n            if (msg.err) {\n              if (ctx.user || opt.secure) {\n                console.log(`error getting ${soul}: ${msg.err}`)\n              } else {\n                console.log(`error getting ${item} on ${soul}: ${msg.err}`)\n              }\n              if (cb) cb(null)\n              return\n            }\n\n            let node = msg.put && msg.put[soul]\n            if (node && typeof node[item] !== \"undefined\") {\n              let id = utils.rel.is(node[item])\n              if (id) {\n                ctx.chain[i].soul = id\n                allctx.set(ctxid, {...ctx})\n                // Call api again using the updated context.\n                if (get) {\n                  api(ctxid).next(null, request.get, cb, request._opt)\n                } else if (put) {\n                  api(ctxid).put(request.put, cb)\n                } else if (on) {\n                  api(ctxid).on(request.on, cb, request._get, request._opt)\n                } else if (off) {\n                  api(ctxid).off(cb)\n                }\n              } else if (get) {\n                // Request was not for a node, return property on current soul.\n                cb(node[item])\n              } else if (put) {\n                // Request was chained before put, so rel doesn't exist yet.\n                id = utils.text.random()\n                node[item] = utils.rel.ify(id)\n                const g = await graph(soul, node, ctx.user, cb)\n                if (g === null) return\n\n                wire.put(g, err => {\n                  if (err) {\n                    cb(`error putting ${item} on ${soul}: ${err}`)\n                    return\n                  }\n\n                  ctx.chain[i].soul = id\n                  api(ctxid).put(request.put, cb)\n                })\n              } else if (on) {\n                // Allow listening to a node that doesn't exist.\n                cb(null)\n              } else if (off) {\n                // Allow stop listening to a node that doesn't exist.\n                if (cb) cb(null)\n              }\n            } else if (put) {\n              // Request was chained before put, so rel doesn't exist yet.\n              const id = utils.text.random()\n              if (!node) node = {}\n              node[item] = utils.rel.ify(id)\n              const g = await graph(soul, node, ctx.user, cb)\n              if (g === null) return\n\n              wire.put(g, err => {\n                if (err) {\n                  cb(`error putting ${item} on ${soul}: ${err}`)\n                  return\n                }\n\n                ctx.chain[i].soul = id\n                api(ctxid).put(request.put, cb)\n              })\n            } else {\n              // Allow querying a node that doesn't exist.\n              if (cb) cb(null)\n            }\n          },\n          request._opt,\n        )\n        // Callback has been passed to next soul lookup or called above, so\n        // return false as the calling code should not continue.\n        return false\n      }\n\n      if (get && ctx.chain[ctx.chain.length - 1].item !== null) {\n        // The context has been resolved but it does not include the requested\n        // node, which requires one more lookup.\n        ctx.chain.push({item: null, soul: null})\n        api(ctxid).next(null, request.get, cb, request._opt)\n        return false\n      }\n\n      // Return the last context, ie the soul required by the calling code.\n      return ctx.chain[ctx.chain.length - 1]\n    }\n\n    return {\n      get: (key, lex, cb, _opt) => {\n        if (typeof lex === \"function\") {\n          _opt = cb\n          cb = lex\n          lex = null\n        }\n        if (key === null || key === \"\" || key === \"_\") {\n          console.log(\"error please provide a key\")\n          if (cb) cb(null)\n          return\n        }\n\n        // lex requires a callback as it's not included in the chain below.\n        if (lex && typeof cb !== \"function\") {\n          console.log(\"error lex requires a callback function\")\n          return\n        }\n\n        // Top level keys are added to a root node so their values don't need\n        // to be objects.\n        ctxid = utils.text.random()\n        allctx.set(ctxid, {chain: [{item: key, soul: \"root\"}], cb: cb})\n        if (!cb) return api(ctxid)\n\n        const _done = done(ctxid)\n        // When there's a callback need to resolve the context first.\n        const {soul} = resolve({get: lex, _opt: _opt}, _done)\n        if (soul) get(lex, soul, _done, _opt)\n      },\n      next: (key, lex, cb, _opt) => {\n        // ack needs to work the same as done, pass it the context id and then\n        // return a new function for the actual callback.\n        const ack = ctxid => {\n          return data => {\n            if (cb) {\n              cb(data)\n            } else {\n              done(ctxid)(data)\n            }\n          }\n        }\n        if (typeof lex === \"function\") {\n          _opt = cb\n          cb = lex\n          lex = null\n        }\n        if (!ctxid) {\n          console.log(\"error please provide a key using get(key)\")\n          if (cb) cb(null)\n          return\n        }\n\n        const _ack = ack(ctxid)\n        if (key === \"\" || key === \"_\") {\n          _ack(null)\n          return\n        }\n\n        // lex requires a callback as it's not included in the chain below.\n        if (lex && typeof cb !== \"function\") {\n          console.log(\"error lex requires a callback function\")\n          return\n        }\n\n        const ctx = allctx.get(ctxid)\n        // ctx already removed by another chained callback is ok?\n        if (!ctx) return\n\n        if (cb && typeof ctx.cb === \"undefined\") {\n          // This (and ack) allows nested objects to set their own callbacks.\n          ctx.cb = cb\n          cb = null\n        }\n\n        // Push the key to the context as it needs a soul lookup.\n        // (null is used to call the api with updated context)\n        if (key !== null) ctx.chain.push({item: key, soul: null})\n        if (!ctx.cb) return api(ctxid)\n\n        // When there's a callback need to resolve the context first.\n        const {soul} = resolve({get: lex, _opt: _opt}, _ack)\n        if (soul) get(lex, soul, _ack, _opt)\n      },\n      put: (data, set, cb) => {\n        if (typeof set === \"function\") {\n          cb = set\n          set = false\n        }\n        const ack = ctxid => {\n          return data => {\n            if (cb) {\n              cb(data)\n            } else {\n              done(ctxid)(data)\n            }\n          }\n        }\n        if (!ctxid) {\n          if (cb) cb(\"error please provide a key using get(key)\")\n          return\n        }\n\n        const ctx = allctx.get(ctxid)\n        // ctx already removed by another chained callback is ok?\n        if (!ctx) return\n\n        if (!ctx.cb) {\n          if (!cb) return\n\n          // This (and ack) allows nested objects to set their own callbacks.\n          ctx.cb = cb\n          cb = null\n        }\n        if (set) data = {[utils.text.random()]: data}\n\n        const _ack = ack(ctxid)\n        const result = check(data)\n        if (typeof result === \"string\") {\n          // All strings returned from check are errors, cannot continue.\n          _ack(result)\n          return\n        }\n\n        // Resolve the current context before putting data. (Note that set is\n        // not passed to resolve because it's already been applied above.)\n        const {item, soul} = resolve({put: data}, _ack)\n        if (!soul) return\n\n        if (result === true) {\n          // When result is true data is a property to put on the current soul.\n          // Need to check if item is a rel and also set the node to null. (This\n          // applies for any update from a rel to a property, not just null.)\n          wire.get({\"#\": soul, \".\": item}, async msg => {\n            if (msg.err) {\n              _ack(`error getting ${soul}: ${msg.err}`)\n              return\n            }\n\n            let node = msg.put && msg.put[soul]\n            const current = node && node[item]\n            const id = utils.rel.is(current)\n            if (!id) {\n              // Not a rel, can just put the data.\n              if (!node) node = {}\n              node[item] = data\n              const g = await graph(soul, node, ctx.user, _ack)\n              if (g === null) return\n\n              wire.put(g, _ack)\n              return\n            }\n\n            wire.get({\"#\": id}, async msg => {\n              if (msg.err) {\n                _ack(`error getting ${id}: ${msg.err}`)\n                return\n              }\n\n              if (!msg.put || !msg.put[id]) {\n                _ack(`error ${id} not found`)\n                return\n              }\n\n              // null each of the properties on the node before putting data.\n              for (const key of Object.keys(msg.put[id])) {\n                if (\n                  key === \"_\" ||\n                  key === utils.userPublicKey ||\n                  key === utils.userSignature\n                ) {\n                  continue\n                }\n\n                const err = await new Promise(res => {\n                  const _ctxid = utils.text.random()\n                  const chain = [{item: key, soul: id}]\n                  allctx.set(_ctxid, {chain: chain, user: ctx.user})\n                  api(_ctxid).put(null, res)\n                })\n                if (err) {\n                  _ack(err)\n                  return\n                }\n              }\n              if (!node) node = {}\n              node[item] = data\n              const g = await graph(soul, node, ctx.user, _ack)\n              if (g === null) return\n\n              wire.put(g, _ack)\n            })\n          })\n          return\n        }\n\n        // Otherwise put the data using the keys returned in result.\n        // Need to check if a rel has already been added on the current node.\n        wire.get({\"#\": soul, \".\": item}, async msg => {\n          if (msg.err) {\n            _ack(`error getting ${soul}.${item}: ${msg.err}`)\n            return\n          }\n\n          let node = msg.put && msg.put[soul]\n          const current = node && node[item]\n          const id = utils.rel.is(current)\n          if (!id) {\n            // The current rel doesn't exist, so add it first.\n            if (!node) node = {}\n            node[item] = utils.rel.ify(utils.text.random())\n            const g = await graph(soul, node, ctx.user, _ack)\n            if (g === null) return\n\n            wire.put(g, err => {\n              if (err) {\n                _ack(`error putting ${item} on ${soul}: ${err}`)\n              } else {\n                const _ctxid = utils.text.random()\n                const chain = [{item: item, soul: soul}]\n                // Pass on the previous context's callback and user flag here.\n                allctx.set(_ctxid, {chain: chain, user: ctx.user, cb: ctx.cb})\n                api(_ctxid).put(data)\n              }\n            })\n            return\n          }\n\n          const update = []\n          for (const key of result) {\n            const err = await new Promise(res => {\n              if (utils.obj.is(data[key]) && !utils.rel.is(data[key])) {\n                // Use the current rel as the context for nested objects.\n                const _ctxid = utils.text.random()\n                const chain = [{item: key, soul: id}]\n                allctx.set(_ctxid, {chain: chain, user: ctx.user})\n                api(_ctxid).put(data[key], res)\n              } else {\n                // Group the rest of the updates for put below.\n                update.push(key)\n                res(null)\n              }\n            })\n            if (err) {\n              _ack(err, ctxid)\n              return\n            }\n          }\n\n          if (update.length === 0) {\n            _ack(null)\n            return\n          }\n\n          // The nested objects created above will also have rels on the parent\n          // object, so fetch the node so the rest of the updates can be added.\n          wire.get({\"#\": id}, async msg => {\n            if (msg.err) {\n              _ack(`error getting ${id}: ${msg.err}`)\n              return\n            }\n\n            let node = msg.put && msg.put[id]\n            if (!node) node = {}\n            update.forEach(key => {\n              node[key] = data[key]\n            })\n            const g = await graph(id, node, ctx.user, _ack)\n            if (g === null) return\n\n            wire.put(g, _ack)\n          })\n        })\n      },\n      on: (lex, cb, _get, _opt) => {\n        if (typeof lex === \"function\") {\n          _opt = _get\n          _get = cb\n          cb = lex\n          lex = null\n        }\n        if (typeof cb !== \"function\") {\n          console.log(\"error on() requires a callback function\")\n          return\n        }\n\n        if (!ctxid) {\n          console.log(\"error please provide a key using get(key)\")\n          cb(null)\n          return\n        }\n\n        // Resolve the current context before adding event listener.\n        const {item, soul} = resolve({on: lex, _get: _get, _opt: _opt}, cb)\n        if (!soul) return\n\n        // Flag that this context is set from on and shouldn't be removed.\n        allctx.set(ctxid, {chain: [{item: item, soul: soul}], on: true})\n        // Map the user's callback because it can also be passed to off,\n        // so need a reference to it to compare them.\n        // Create a new context for each listener invocation to avoid mutation\n        map.set(cb, () => {\n          // When listener fires, re-check if the item is now a rel.\n          wire.get(\n            {\"#\": soul, \".\": item},\n            msg => {\n              const current = msg.put && msg.put[soul] && msg.put[soul][item]\n              const id = utils.rel.is(current)\n              if (id) {\n                // It's a rel, read the related node. It might not be in the graph\n                // yet when the listener fires, so we retry with delays.\n                const attemptRead = async (retries = 0) => {\n                  const data = await new Promise(res => {\n                    const _ctxid = utils.text.random()\n                    allctx.set(_ctxid, {chain: [{item: null, soul: id}]})\n                    api(_ctxid).next(null, res, _opt)\n                  })\n                  if (data !== null || retries >= 5) {\n                    cb(data)\n                  } else {\n                    // Data not ready, retry after delay\n                    await new Promise(resolve => setTimeout(resolve, 50))\n                    attemptRead(retries + 1)\n                  }\n                }\n                attemptRead()\n              } else {\n                // It's a direct property or null\n                cb(current !== undefined ? current : null)\n              }\n            },\n            _opt,\n          )\n        })\n\n        // Register listener immediately to avoid missing updates due to\n        // queueing. Initially register the soul without _get, then update if\n        // it's a rel.\n        let initialLex\n        if (lex) initialLex = utils.obj.put(lex, \"#\", soul)\n        else initialLex = {\"#\": soul, \".\": item}\n        wire.on(initialLex, map.get(cb), false, _opt)\n\n        // Check if item is a rel and update listener if needed.\n        // This happens async but the listener is already registered above.\n        wire.get(\n          {\"#\": soul, \".\": item},\n          msg => {\n            if (msg.err) {\n              console.log(`error getting ${soul}.${item}: ${msg.err}`)\n              return\n            }\n\n            const current = msg.put && msg.put[soul] && msg.put[soul][item]\n            const id = utils.rel.is(current)\n            if (id) {\n              // It's a rel, need to switch listener to the related node\n              // First remove the initial listener\n              wire.off(initialLex, map.get(cb))\n              // Then add listener on the related node\n              let relLex\n              if (lex) relLex = utils.obj.put(lex, \"#\", id)\n              else relLex = {\"#\": id, \".\": null}\n              wire.on(relLex, map.get(cb), _get, _opt)\n            } else if (_get) {\n              // Not a rel, but _get was requested, so trigger callback.\n              map.get(cb)()\n            }\n          },\n          _opt,\n        )\n      },\n      off: cb => {\n        if (!ctxid) {\n          console.log(\"error please provide a key using get(key)\")\n          if (cb) cb(null)\n          return\n        }\n\n        // Resolve the current context before removing event listener.\n        const {item, soul} = resolve({off: true}, cb)\n        if (!soul) return\n\n        // Check if item is a rel and remove event listener for the node.\n        wire.get({\"#\": soul, \".\": item}, msg => {\n          if (msg.err) {\n            console.log(`error getting ${soul}.${item}: ${msg.err}`)\n            return\n          }\n\n          const current = msg.put && msg.put[soul] && msg.put[soul][item]\n          const id = utils.rel.is(current)\n          if (id) wire.off({\"#\": id}, map.get(cb))\n          else wire.off({\"#\": soul}, map.get(cb))\n          map.delete(cb)\n          allctx.delete(ctxid)\n        })\n      },\n      user: () => {\n        if (!user.get) {\n          // Return the combined Holster and User APIs.\n          Object.assign(user, api())\n          // Need to provide a user specific get() function to know if user\n          // context should be checked.\n          user.get = (keys, lex, cb, _opt) => {\n            if (typeof lex === \"function\") {\n              _opt = cb\n              cb = lex\n              lex = null\n            }\n\n            let pub = null\n            let key = null\n            if (user.is) pub = user.is.pub\n            if (typeof keys === \"string\") {\n              key = keys\n            } else if (keys instanceof Array) {\n              if (keys.length === 2) {\n                pub = keys[0]\n                key = keys[1]\n              } else if (keys.length === 1) {\n                key = keys[0]\n              }\n            }\n            if (!pub) {\n              console.log(\"error please log in or provide a public key\")\n              if (cb) cb(null)\n              return\n            }\n\n            if (key === null || key === \"\" || key === \"_\") {\n              console.log(\"error please provide a key\")\n              if (cb) cb(null)\n              return\n            }\n\n            // lex requires a callback as it's not included in the chain below.\n            if (lex && !cb) {\n              console.log(\"error lex requires a callback function\")\n              return\n            }\n\n            ctxid = utils.text.random()\n            const chain = [{item: key, soul: \"~\" + pub}]\n            allctx.set(ctxid, {chain: chain, user: user.is, cb: cb})\n            if (!cb) return api(ctxid)\n\n            // When there's a callback need to resolve the context first.\n            const _done = done(ctxid)\n            const {soul} = resolve({get: lex, _opt: _opt}, _done)\n            if (soul) get(lex, soul, _done, _opt)\n          }\n        }\n        return user\n      },\n      // Allow the wire spec to be used via holster.\n      wire: wire,\n      // Allow SEA functions to be used via holster.\n      SEA: SEA,\n    }\n  }\n  return api()\n}\n\nexport default Holster\n"],
  "mappings": "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",
  "names": ["num", "n", "parsed", "obj", "o", "match", "list", "cb", "keys", "i", "result", "key", "value", "map_soul", "soul", "rel", "userSignature", "userPublicKey", "graph", "data", "sig", "pub", "timestamp", "g", "signature", "lex", "prefix", "gt", "lt", "text", "length", "s", "c", "Dup", "maxAge", "dup", "id", "now", "dup_default", "Get", "lex", "graph", "soul", "node", "signatures", "key", "match", "get_default", "data", "SeaArray", "enc", "start", "end", "buf", "byte", "_", "i", "charCode", "utf8String", "array_default", "SECURITY_LIMITS", "SafeBuffer", "props", "validateStringInput", "input", "encoding", "validateBufferSize", "size", "operation", "parseHexString", "hexString", "cleanHex", "bytes", "i", "hexByte", "encodeUtf8String", "str", "err", "encodeBinaryString", "charCode", "parseBase64String", "base64String", "cleanBase64", "decodedString", "processArrayLikeInput", "val", "arr", "array_default", "length", "fill", "buffer", "totalLength", "validatedBuffers", "item", "result", "offset", "obj", "string", "clean", "start", "end", "buffer_default", "isNode", "crypto", "subtle", "stringify", "data", "parse", "text", "random", "length", "array", "buffer_default", "jwk", "pub", "priv", "x", "y", "sha256", "hash", "aeskey", "key", "salt", "combined", "keyToJwk", "SEA", "cb", "ecdsa", "subtle", "keys", "pub", "ecdh", "pair", "data", "rand", "random", "ct", "aeskey", "aes", "stringify", "enc", "buffer_default", "dec", "parse", "signed", "key", "jwk", "msg", "k", "userPublicKey", "userSignature", "hash", "sha256", "sig", "alg", "verified", "node", "valid", "propertySignatures", "propSig", "err", "check", "salt", "work", "to", "from", "pubKey", "priv", "derived", "derivedBits", "derivedKey", "sea_default", "LISTENER_DELAY", "MAX_GRAPH_SIZE", "Ham", "state", "currentState", "value", "currentValue", "change", "graph", "secure", "listen", "machine", "now", "defer", "validProperties", "wait", "soul", "node", "updated", "alias", "nodeWait", "verify", "pub", "userPublicKey", "validProps", "sea_default", "key", "userSignature", "rel", "skew", "l", "match", "souls", "states", "maxState", "a", "b", "ham_default", "group", "record", "Radix", "radix", "keys", "value", "tree", "i", "tmp", "key", "max", "noValue", "found", "obj", "hasValue", "hasKey", "j", "matchingKey", "replace", "map", "cb", "opt", "pre", "u", "radix_default", "etx", "enq", "unit", "Radisk", "opt", "u", "cache", "fileListCache", "fileListCacheTime", "FILE_LIST_CACHE_TTL", "pendingReads", "lastMemoryCheck", "MEMORY_CHECK_INTERVAL", "HEAP_WARNING_THRESHOLD", "HEAP_CLEANUP_THRESHOLD", "perfLog", "operation", "startTime", "key", "size", "duration", "checkMemoryUsage", "now", "memUsage", "heapUsed", "heapTotal", "maxHeapSize", "heapUsageRatio", "cacheSize", "radisk", "value", "cb", "readStart", "err", "result", "callbacks", "callback", "radix_default", "thrashStart", "batch", "i", "rad", "save", "tree", "file", "start", "end", "disk", "write", "k", "pre", "enc", "writeStart", "soul", "read", "cachedRadix", "files", "originalLex", "parse", "data", "preString", "tmp", "a", "o", "state", "sig", "current", "text", "rel", "num", "obj", "previous", "textStart", "textEnd", "parts", "radisk_default", "isNode", "fs", "enq", "unit", "root", "fileSystem", "opt", "dir", "file", "cb", "err", "data", "tmp", "text", "files", "db", "o", "event", "req", "_get", "retry", "interval", "_put", "_list", "Store", "obj", "radisk", "radisk_default", "lex", "soul", "key", "node", "signatures", "each", "value", "match", "graph", "radix_default", "count", "finished", "ack", "state", "sig", "store_default", "isNode", "wsModule", "createRateLimiter", "isTestEnv", "clients", "maxRequests", "windowMs", "disconnectThreshold", "cleanupInterval", "now", "clientId", "data", "time", "client", "oldestRequest", "delay", "validRequests", "safeJSONParse", "maxSize", "error", "validateMessage", "createConnectionManager", "maxConnections", "connections", "ws", "originalClose", "args", "createRetryHandler", "maxRetries", "retryCount", "Wire", "opt", "dup", "dup_default", "store", "store_default", "graph", "queue", "listen", "pendingReferences", "pendingTimeouts", "hasSoul", "soul", "resolve", "err", "rateLimiter", "connectionManager", "check", "send", "cb", "msg", "res", "getWithCallback", "node", "key", "userPublicKey", "get", "ack", "get_default", "text", "put", "update", "ham_default", "lex", "_opt", "obj", "track", "request", "sendResult", "api", "value", "soulId", "rel", "_get", "found", "l", "wss", "config", "isBinary", "trackId", "timeoutConfig", "id", "retryHandler", "validation", "parseResult", "throttleCount", "processMessage", "peers", "clientThrottled", "throttleUntil", "messageQueue", "queueProcessor", "maxQueueLength", "processQueue", "sendToPeers", "sentToAtLeastOne", "peer", "start", "c", "e", "m", "filteredPut", "shouldStore", "filteredMsg", "wire_default", "User", "opt", "wire", "wire_default", "pubs", "creating", "authing", "retries", "auth", "username", "password", "newPassword", "ack", "retry", "done", "err", "next", "pub", "msg", "data", "work", "sea_default", "dec", "user", "salt", "text", "enc", "update", "propertySignatures", "graph", "migrationData", "key", "userPublicKey", "userSignature", "soul", "cb", "pair", "priv", "rel", "localStorage", "is", "user_default", "Holster", "opt", "obj", "wire", "wire_default", "user", "user_default", "map", "allctx", "ok", "data", "rel", "num", "check", "keys", "key", "value", "api", "ctxid", "get", "lex", "soul", "ack", "_opt", "msg", "userPublicKey", "userSignature", "id", "attemptRead", "retries", "res", "_ctxid", "text", "resolve", "graph", "userctx", "cb", "propertySignatures", "sea_default", "done", "ctx", "request", "put", "on", "off", "found", "i", "item", "node", "g", "err", "_done", "_ack", "set", "result", "current", "chain", "update", "_get", "initialLex", "relLex", "pub", "holster_default"]
}
