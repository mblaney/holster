{
  "version": 3,
  "sources": ["../src/utils.js", "../src/dup.js", "../src/get.js", "../src/ham.js", "../src/radix.js", "../src/radisk.js", "../src/store.js", "../src/wire.js", "../src/holster.js"],
  "sourcesContent": ["export const num = {\n  is: n =>\n    !(n instanceof Array) &&\n    (n - parseFloat(n) + 1 >= 0 || Infinity === n || -Infinity === n),\n}\n\nexport const obj = {\n  is: o => {\n    if (!o) return false\n\n    return (\n      (o instanceof Object && o.constructor === Object) ||\n      Object.prototype.toString.call(o).match(/^\\[object (\\w+)\\]$/)[1] ===\n        \"Object\"\n    )\n  },\n  map: (list, cb, o) => {\n    var keys = Object.keys(list)\n    for (let i = 0; i < keys.length; i++) {\n      let result = cb(list[keys[i]], keys[i], o)\n      if (typeof result !== \"undefined\") return result\n    }\n  },\n  put: (o, key, value) => {\n    if (!o) o = {}\n    o[key] = value\n    return o\n  },\n  del: (o, key) => {\n    if (!o) return\n\n    o[key] = null\n    delete o[key]\n    return o\n  },\n}\n\nconst map_soul = (soul, key, o) => {\n  // If id is already defined AND we're still looping through the object,\n  // then it is considered invalid.\n  if (o.id) {\n    o.id = false\n    return\n  }\n\n  if (key === \"#\" && typeof soul === \"string\") {\n    o.id = soul\n    return\n  }\n\n  // If there exists anything else on the object that isn't the soul,\n  // then it is considered invalid.\n  o.id = false\n}\n\n// Check if an object is a soul relation, ie {'#': 'UUID'}\nexport const rel = {\n  is: value => {\n    if (value && value[\"#\"] && !value._ && obj.is(value)) {\n      let o = {}\n      obj.map(value, map_soul, o)\n      if (o.id) return o.id\n    }\n\n    return false\n  },\n  // Convert a soul into a relation and return it.\n  ify: soul => obj.put({}, \"#\", soul),\n}\n\nexport const text = {\n  random: length => {\n    var s = \"\"\n    const c = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXZabcdefghijklmnopqrstuvwxyz\"\n    if (!length) length = 24\n    for (let i = 0; i < length; i++) {\n      s += c.charAt(Math.floor(Math.random() * c.length))\n    }\n    return s\n  },\n}\n", "const Dup = maxAge => {\n  // Allow maxAge to be passed in as tests wait on the setTimeout.\n  if (!maxAge) maxAge = 9000\n  const dup = {store: {}}\n  dup.check = id => (dup.store[id] ? dup.track(id) : false)\n  dup.track = id => {\n    // Keep the liveliness of the message up while it is being received.\n    dup.store[id] = Date.now()\n    if (!dup.expiry) {\n      dup.expiry = setTimeout(() => {\n        const now = Date.now()\n        Object.keys(dup.store).forEach(id => {\n          if (now - dup.store[id] > maxAge) delete dup.store[id]\n        })\n        dup.expiry = null\n      }, maxAge)\n    }\n    return id\n  }\n  return dup\n}\n\nexport default Dup\n", "const Get = (lex, graph) => {\n  const soul = lex[\"#\"]\n  const key = lex[\".\"]\n  var node = graph[soul]\n\n  // Can only return a node if a key is provided, because the graph may not\n  // have all the keys populated for a given soul. This is because Ham.mix\n  // only adds incoming changes to the graph.\n  if (!node || !key) return\n\n  let value = node[key]\n  if (!value) return\n\n  node = {_: node._, [key]: value}\n  node._[\">\"] = {[key]: node._[\">\"][key]}\n  return {[soul]: node}\n}\n\nexport default Get\n", "// ASCII character for enquiry.\nconst enq = String.fromCharCode(5)\n\n// state and value are the incoming changes.\n// currentState and currentValue are the current graph data.\nconst Ham = (state, currentState, value, currentValue) => {\n  if (state < currentState) return {historical: true}\n\n  if (state > currentState) return {incoming: true}\n\n  // state is equal to currentState, lexically compare to resolve conflict.\n  if (typeof value !== \"string\") {\n    value = JSON.stringify(value) || \"\"\n  }\n  if (typeof currentValue !== \"string\") {\n    currentValue = JSON.stringify(currentValue) || \"\"\n  }\n  // No update required.\n  if (value === currentValue) return {state: true}\n\n  // Keep the current value.\n  if (value < currentValue) return {current: true}\n\n  // Otherwise update using the incoming value.\n  return {incoming: true}\n}\n\nHam.mix = (change, graph, listen) => {\n  var machine = Date.now()\n  var now = {}\n  var defer = {}\n  let wait = 0\n\n  Object.keys(change).forEach(soul => {\n    const node = change[soul]\n    let updated = false\n    Object.keys(node).forEach(key => {\n      if (key === \"_\") return\n\n      const value = node[key]\n      const state = node._[\">\"][key]\n      const currentValue = (graph[soul] || {})[key]\n      const currentState = (graph[soul] || {_: {\">\": {}}})._[\">\"][key] || 0\n\n      // Defer the update if ahead of machine time.\n      const skew = state - machine\n      if (skew > 0) {\n        // Ignore update if ahead by more than 24 hours.\n        if (skew > 86400000) return\n\n        // Wait the shortest difference before trying the updates again.\n        if (wait === 0 || skew < wait) wait = skew\n        if (!defer[soul]) defer[soul] = {_: {\"#\": soul, \">\": {}}}\n        defer[soul][key] = value\n        defer[soul]._[\">\"][key] = state\n      } else {\n        const result = Ham(state, currentState, value, currentValue)\n        if (result.incoming) {\n          if (!now[soul]) now[soul] = {_: {\"#\": soul, \">\": {}}}\n          // TODO: graph should not just grow indefintitely in memory.\n          // Need to have a max size after which start dropping the oldest state\n          // Do something similar to Dup which can handle deletes?\n          if (!graph[soul]) graph[soul] = {_: {\"#\": soul, \">\": {}}}\n          graph[soul][key] = now[soul][key] = value\n          graph[soul]._[\">\"][key] = now[soul]._[\">\"][key] = state\n          // Call event listeners for update on key, mix is called before\n          // put has finished so wait for what could be multiple nested\n          // updates on a node.\n          setTimeout(() => {\n            const id = soul + enq + key\n            if (listen[id]) listen[id].forEach(cb => cb())\n          }, 100)\n          updated = true\n        }\n      }\n    })\n    // Call event listeners for update on soul.\n    if (updated && listen[soul])\n      setTimeout(() => {\n        listen[soul].forEach(cb => cb())\n      }, 100)\n  })\n  return {now: now, defer: defer, wait: wait}\n}\n\nexport default Ham\n", "import * as utils from \"./utils.js\"\n\n// ASCII character for group separator.\nconst group = String.fromCharCode(29)\n// ASCII character for record separator.\nconst record = String.fromCharCode(30)\n\nconst Radix = () => {\n  const radix = (keys, value, tree) => {\n    if (!tree) {\n      if (!radix[group]) radix[group] = {}\n      tree = radix[group]\n    }\n    if (!keys) return tree\n\n    let i = 0\n    let tmp = {}\n    let key = keys[i]\n    const max = keys.length - 1\n    const noValue = typeof value === \"undefined\"\n    // Find a matching value using the shortest string from keys.\n    let found = tree[key]\n    while (!found && i < max) {\n      key += keys[++i]\n      found = tree[key]\n    }\n\n    if (!found) {\n      // If not found from the provided keys try matching with an existing key.\n      const result = utils.obj.map(tree, (hasValue, hasKey) => {\n        let j = 0\n        let matchingKey = \"\"\n        while (hasKey[j] === keys[j]) {\n          matchingKey += hasKey[j++]\n        }\n        if (matchingKey) {\n          if (noValue) {\n            // matchingKey has to be as long as the original keys when reading.\n            if (j <= max) return\n\n            tmp[hasKey.slice(j)] = hasValue\n            return hasValue\n          }\n\n          let replace = {\n            [hasKey.slice(j)]: hasValue,\n            [keys.slice(j)]: {[record]: value},\n          }\n          tree[matchingKey] = {[group]: replace}\n          delete tree[hasKey]\n          return true\n        }\n      })\n      if (!result) {\n        if (noValue) return\n\n        if (!tree[key]) tree[key] = {}\n        tree[key][record] = value\n      } else if (noValue) {\n        return tmp\n      }\n    } else if (i === max) {\n      // If no value use the key provided to return a whole group or record.\n      if (noValue) {\n        // If an individual record isn't found then return the whole group.\n        return typeof found[record] === \"undefined\"\n          ? found[group]\n          : found[record]\n      }\n      // Otherwise create a new record at the provided key for value.\n      found[record] = value\n    } else {\n      // Found at a shorter key, try again.\n      if (!found[group] && !noValue) found[group] = {}\n      return radix(keys.slice(++i), value, found[group])\n    }\n  }\n  return radix\n}\n\nRadix.map = function map(radix, cb, opt, pre) {\n  if (!pre) pre = []\n  var tree = radix[group] || radix\n  var keys = Object.keys(tree).sort()\n  var u\n\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i]\n    let found = tree[key]\n    let tmp = found[record]\n    if (typeof tmp !== \"undefined\") {\n      tmp = cb(tmp, pre.join(\"\") + key, key, pre)\n      if (typeof tmp !== \"undefined\") return tmp\n    } else if (opt) {\n      cb(u, pre.join(\"\"), key, pre)\n    }\n    if (found[group]) {\n      pre.push(key)\n      tmp = map(found[group], cb, opt, pre)\n      if (typeof tmp !== \"undefined\") return tmp\n      pre.pop()\n    }\n  }\n}\n\nexport default Radix\n", "import Radix from \"./radix.js\"\nimport * as utils from \"./utils.js\"\n\n// ASCII character for end of text.\nconst etx = String.fromCharCode(3)\n// ASCII character for enquiry.\nconst enq = String.fromCharCode(5)\n// ASCII character for unit separator.\nconst unit = String.fromCharCode(31)\n\n// Radisk provides access to a radix tree that is stored in the provided\n// opt.store interface.\nconst Radisk = opt => {\n  var u\n  var cache = null\n\n  if (!opt) opt = {}\n  if (!opt.log) opt.log = console.log\n  if (!opt.batch) opt.batch = 10 * 1000\n  if (!opt.write) opt.write = 1 // Wait time before write in milliseconds.\n  if (!opt.size) opt.size = 1024 * 1024 // File size on disk, default 1MB.\n  if (!opt.store) {\n    opt.log(\n      \"Radisk needs `store` interface with `{get: fn, put: fn, list: fn}`\",\n    )\n    return\n  }\n  if (!opt.store.get) {\n    opt.log(\"Radisk needs `store.get` interface with `(file, cb)`\")\n    return\n  }\n  if (!opt.store.put) {\n    opt.log(\"Radisk needs `store.put` interface with `(file, data, cb)`\")\n    return\n  }\n  if (!opt.store.list) {\n    opt.log(\"Radisk needs a streaming `store.list` interface with `(cb)`\")\n    return\n  }\n\n  // Any and all storage adapters should:\n  // 1. Because writing to disk takes time, we should batch data to disk.\n  //    This improves performance, and reduces potential disk corruption.\n  // 2. If a batch exceeds a certain number of writes, we should immediately\n  //    write to disk when physically possible. This caps total performance,\n  //    but reduces potential loss.\n  const radisk = (key, value, cb) => {\n    key = \"\" + key\n\n    // If no value is provided then the second parameter is the callback\n    // function. Read value from memory or disk and call callback with it.\n    if (typeof value === \"function\") {\n      cb = value\n      value = radisk.batch(key)\n      if (typeof value !== \"undefined\") {\n        return cb(u, value)\n      }\n\n      if (radisk.thrash.at) {\n        value = radisk.thrash.at(key)\n        if (typeof value !== \"undefined\") {\n          return cb(u, value)\n        }\n      }\n\n      return radisk.read(key, cb)\n    }\n\n    // Otherwise store the value provided.\n    radisk.batch(key, value)\n    if (cb) {\n      radisk.batch.acks.push(cb)\n    }\n    // Don't wait if we have batched too many.\n    if (++radisk.batch.ed >= opt.batch) {\n      return radisk.thrash()\n    }\n\n    // Otherwise wait for more updates before writing.\n    clearTimeout(radisk.batch.timeout)\n    radisk.batch.timeout = setTimeout(radisk.thrash, opt.write)\n  }\n\n  radisk.batch = Radix()\n  radisk.batch.acks = []\n  radisk.batch.ed = 0\n\n  radisk.thrash = () => {\n    if (radisk.thrash.ing) {\n      return (radisk.thrash.more = true)\n    }\n\n    clearTimeout(radisk.batch.timeout)\n    radisk.thrash.more = false\n    radisk.thrash.ing = true\n    var batch = (radisk.thrash.at = radisk.batch)\n    radisk.batch = null\n    radisk.batch = Radix()\n    radisk.batch.acks = []\n    radisk.batch.ed = 0\n    let i = 0\n    radisk.save(batch, err => {\n      // This is to ignore multiple callbacks from radisk.save calling\n      // radisk.write? It looks like multiple callbacks will be made if a\n      // file needs to be split.\n      if (++i > 1) return\n\n      if (err) opt.log(err)\n      batch.acks.forEach(cb => cb(err))\n      radisk.thrash.at = null\n      radisk.thrash.ing = false\n      if (radisk.thrash.more) radisk.thrash()\n    })\n  }\n\n  // 1. Find the first radix item in memory\n  // 2. Use that as the starting index in the directory of files\n  // 3. Find the first file that is lexically larger than it\n  // 4. Read the previous file into memory\n  // 5. Scan through in memory radix for all values lexically less than limit\n  // 6. Merge and write all of those to the in-memory file and back to disk\n  // 7. If file is to large then split. More details needed here\n  radisk.save = (rad, cb) => {\n    const save = {\n      find: (tree, key) => {\n        // This is false for any key until save.start is set to an initial key.\n        if (key < save.start) return\n\n        save.start = key\n        opt.store.list(save.lex)\n        return true\n      },\n      lex: file => {\n        if (!file || file > save.start) {\n          save.end = file\n          // ! is used as the first file name as it's the first printable\n          // character, so always matches as lexically less than any node.\n          save.mix(save.file || \"!\", save.start, save.end)\n          return true\n        }\n\n        save.file = file\n      },\n      mix: (file, start, end) => {\n        save.start = save.end = save.file = u\n        radisk.parse(file, (err, disk) => {\n          if (err) return cb(err)\n\n          Radix.map(rad, (value, key) => {\n            if (key < start) return\n\n            if (end && end < key) {\n              save.start = key\n              return save.start\n            }\n\n            disk(key, value)\n          })\n          radisk.write(file, disk, save.next)\n        })\n      },\n      next: err => {\n        if (err) return cb(err)\n\n        if (save.start) return Radix.map(rad, save.find)\n\n        cb(err)\n      },\n    }\n    Radix.map(rad, save.find)\n  }\n\n  radisk.write = (file, rad, cb) => {\n    // Invalidate cache on write.\n    cache = null\n    const write = {\n      text: \"\",\n      count: 0,\n      file: file,\n      each: (value, key, k, pre) => {\n        write.count++\n        var enc =\n          Radisk.encode(pre.length) +\n          \"#\" +\n          Radisk.encode(k) +\n          (typeof value === \"undefined\" ? \"\" : \"=\" + Radisk.encode(value)) +\n          \"\\n\"\n        // Cannot split the file if only have one entry to write.\n        if (write.count > 1 && write.text.length + enc.length > opt.size) {\n          write.text = \"\"\n          // Otherwise split the entries in half.\n          write.limit = Math.ceil(write.count / 2)\n          write.count = 0\n          write.sub = Radix()\n          Radix.map(rad, write.slice)\n          return true\n        }\n\n        write.text += enc\n      },\n      put: () => {\n        opt.store.put(file, write.text, cb)\n      },\n      slice: (value, key) => {\n        if (key < write.file) return\n\n        if (++write.count > write.limit) {\n          var name = write.file\n          // Use only the soul of the key as the filename so that all\n          // properties of a soul are written to the same file.\n          let end = key.indexOf(enq)\n          if (end === -1) {\n            write.file = key\n          } else {\n            write.file = key.substring(0, end)\n          }\n          // write.limit can be reached after already writing properties of\n          // the current node, so remove it from write.sub before writing to\n          // disk so that it's not duplicated across files.\n          write.sub(write.file, null)\n          write.count = 0\n          radisk.write(name, write.sub, write.next)\n          return true\n        }\n\n        write.sub(key, value)\n      },\n      next: err => {\n        if (err) return cb(err)\n\n        write.sub = Radix()\n        if (!Radix.map(rad, write.slice)) {\n          radisk.write(write.file, write.sub, cb)\n        }\n      },\n    }\n    // If Radix.map doesn't return true when called with write.each as a\n    // callback then didn't need to split the data. The accumulated write.text\n    // can then be stored with write.put().\n    if (!Radix.map(rad, write.each, true)) write.put()\n  }\n\n  radisk.read = (key, cb) => {\n    if (cache) {\n      let value = cache(key)\n      if (typeof value !== \"undefined\") return cb(u, value)\n    }\n    // Only the soul of the key is compared to filenames (see radisk.write).\n    let soul = key\n    let end = key.indexOf(enq)\n    if (end !== -1) {\n      soul = key.substring(0, end)\n    }\n\n    const read = {\n      lex: file => {\n        // store.list should call lex without a file last, which means all file\n        // names were compared to soul, so the current read.file is ok to use.\n        if (!file) {\n          if (!read.file) {\n            cb(\"no file found\", u)\n            return\n          }\n\n          radisk.parse(read.file, read.it)\n          return\n        }\n\n        // Want the filename closest to soul.\n        if (file > soul || file < read.file) return\n\n        read.file = file\n      },\n      it: (err, disk) => {\n        if (err) opt.log(err)\n        if (disk) {\n          cache = disk\n          read.value = disk(key)\n        }\n        cb(err, read.value)\n      },\n    }\n    opt.store.list(read.lex)\n  }\n\n  // Let us start by assuming we are the only process that is\n  // changing the directory or bucket. Not because we do not want\n  // to be multi-process/machine, but because we want to experiment\n  // with how much performance and scale we can get out of only one.\n  // Then we can work on the harder problem of being multi-process.\n  radisk.parse = (file, cb) => {\n    const parse = {\n      disk: Radix(),\n      read: (err, data) => {\n        if (err) return cb(err)\n\n        if (!data) return cb(u, parse.disk)\n\n        let pre = []\n        // Work though data by splitting into 3 values. The first value says\n        // if the second value is one of: the radix level for a key, the key\n        // iteself, or a value. The third is the rest of the data to work with.\n        let tmp = parse.split(data)\n        while (tmp) {\n          let key\n          let value\n          let i = tmp[1]\n          tmp = parse.split(tmp[2]) || \"\"\n          if (tmp[0] === \"#\") {\n            key = tmp[1]\n            pre = pre.slice(0, i)\n            if (i <= pre.length) pre.push(key)\n          }\n          tmp = parse.split(tmp[2]) || \"\"\n          if (tmp[0] === \"\\n\") continue\n\n          if (tmp[0] === \"=\") value = tmp[1]\n          if (typeof key !== \"undefined\" && typeof value !== \"undefined\") {\n            parse.disk(pre.join(\"\"), value)\n          }\n          tmp = parse.split(tmp[2])\n        }\n        cb(u, parse.disk)\n      },\n      split: data => {\n        if (!data) return\n\n        let i = -1\n        let a = \"\"\n        let c = null\n        while ((c = data[++i])) {\n          if (c === unit) break\n\n          a += c\n        }\n        let o = {}\n        if (c) {\n          return [a, Radisk.decode(data.slice(i), o), data.slice(i + o.i)]\n        }\n      },\n    }\n    opt.store.get(file, parse.read)\n  }\n\n  return radisk\n}\n\nRadisk.encode = data => {\n  // A key should be passed in as a string to encode, a value can optionally be\n  // an array of 2 items to include the value's state, as is done by store.js.\n  let state = \"\"\n  if (data instanceof Array && data.length === 2) {\n    state = etx + data[1]\n    data = data[0]\n  }\n\n  if (typeof data === \"string\") {\n    let i = 0\n    let current = null\n    let text = unit\n    while ((current = data[i++])) {\n      if (current === unit) text += unit\n    }\n    return text + '\"' + data + state + unit\n  }\n\n  const rel = utils.rel.is(data)\n  if (rel) return unit + \"#\" + rel + state + unit\n\n  if (utils.num.is(data)) return unit + \"+\" + (data || 0) + state + unit\n\n  if (data === true) return unit + \"+\" + state + unit\n\n  if (data === false) return unit + \"-\" + state + unit\n\n  if (data === null) return unit + \" \" + state + unit\n}\n\nRadisk.decode = (data, obj) => {\n  var text = \"\"\n  var i = -1\n  var n = 0\n  var current = null\n  var previous = null\n  if (data[0] !== unit) return\n\n  // Find a control character previous to the text we want, skipping\n  // consecutive unit separator characters at the beginning of the data.\n  while ((current = data[++i])) {\n    if (previous) {\n      if (current === unit) {\n        if (--n <= 0) break\n      }\n      text += current\n    } else if (current === unit) {\n      n++\n    } else {\n      previous = current || true\n    }\n  }\n\n  if (obj) obj.i = i + 1\n\n  let [value, state] = text.split(etx)\n  if (!state) {\n    if (previous === '\"') return text\n\n    if (previous === \"#\") return utils.rel.ify(text)\n\n    if (previous === \"+\") {\n      if (text.length === 0) return true\n\n      return parseFloat(text)\n    }\n\n    if (previous === \"-\") return false\n\n    if (previous === \" \") return null\n  } else {\n    state = parseFloat(state)\n    // If state was found then return an array.\n    if (previous === '\"') return [value, state]\n\n    if (previous === \"#\") return [utils.rel.ify(value), state]\n\n    if (previous === \"+\") {\n      if (value.length === 0) return [true, state]\n\n      return [parseFloat(value), state]\n    }\n\n    if (previous === \"-\") return [false, state]\n\n    if (previous === \" \") return [null, state]\n  }\n}\n\nexport default Radisk\n", "import Radisk from \"./radisk.js\"\nimport Radix from \"./radix.js\"\nimport * as utils from \"./utils.js\"\n\nconst isNode = typeof document === \"undefined\"\nconst fs = isNode ? await import(\"node:fs\") : undefined\n\n// ASCII character for enquiry.\nconst enq = String.fromCharCode(5)\n// ASCII character for unit separator.\nconst unit = String.fromCharCode(31)\n// On-disk root node format.\nconst root = unit + \"+0\" + unit + \"#\" + unit + '\"root' + unit\n\nconst fileSystem = opt => {\n  const dir = opt.file\n\n  if (isNode) {\n    if (!fs.existsSync(dir)) fs.mkdirSync(dir)\n    if (!fs.existsSync(dir + \"/!\")) fs.writeFileSync(dir + \"/!\", root)\n\n    return {\n      get: (file, cb) => {\n        fs.readFile(dir + \"/\" + file, (err, data) => {\n          if (err) {\n            if (err.code === \"ENOENT\") {\n              cb()\n              return\n            }\n\n            console.log(\"fs.readFile error:\", err)\n          }\n          if (data) data = data.toString()\n          cb(err, data)\n        })\n      },\n      put: (file, data, cb) => {\n        var random = Math.random().toString(36).slice(-9)\n        // Don't put tmp files under dir so that they're not listed.\n        var tmp = file + \".\" + random + \".tmp\"\n        fs.writeFile(tmp, data, err => {\n          if (err) {\n            cb(err)\n            return\n          }\n\n          fs.rename(tmp, dir + \"/\" + file, cb)\n        })\n      },\n      list: cb => {\n        fs.readdir(dir, (err, files) => {\n          files.forEach(cb)\n          cb()\n        })\n      },\n    }\n  }\n\n  if (opt.indexedDB) {\n    let db\n    const o = indexedDB.open(dir, 1)\n    o.onupgradeneeded = event => {\n      event.target.result.createObjectStore(dir)\n    }\n    o.onerror = event => {\n      console.log(event)\n    }\n    o.onsuccess = () => {\n      db = o.result\n      // Create the root node if it doesn't exist.\n      if (db) {\n        const tx = db.transaction([dir], \"readonly\")\n        const req = tx.objectStore(dir).getKey(\"!\")\n        req.onerror = () => {\n          console.log(`error getting key ${dir}/!`)\n        }\n        req.onsuccess = () => {\n          if (!req.result) {\n            const tx = db.transaction([dir], \"readwrite\")\n            const req = tx.objectStore(dir).put(root, \"!\")\n            req.onerror = () => {\n              console.log(`error putting root on ${dir}/!`)\n            }\n          }\n        }\n      } else {\n        console.log(\"error indexedDB not available\")\n      }\n    }\n\n    return {\n      get: (file, cb) => {\n        if (db) {\n          const tx = db.transaction([dir], \"readonly\")\n          const req = tx.objectStore(dir).get(file)\n          req.onerror = () => {\n            console.log(`error getting ${dir}/${file}`)\n          }\n          req.onsuccess = () => {\n            cb(null, req.result)\n          }\n        } else {\n          cb(\"error indexedDB not available\")\n        }\n      },\n      put: (file, data, cb) => {\n        if (db) {\n          const tx = db.transaction([dir], \"readwrite\")\n          const req = tx.objectStore(dir).put(data, file)\n          req.onerror = () => {\n            console.log(`error putting data on ${dir}/${file}`)\n          }\n          req.onsuccess = () => {\n            cb(null)\n          }\n        } else {\n          cb(\"error indexedDB not available\")\n        }\n      },\n      list: cb => {\n        if (db) {\n          const tx = db.transaction([dir], \"readonly\")\n          const req = tx.objectStore(dir).getAllKeys()\n          req.onerror = () => console.log(\"error getting keys for\", dir)\n          req.onsuccess = () => {\n            req.result.forEach(cb)\n            cb()\n          }\n        } else {\n          console.log(\"error indexedDB not available\")\n          cb()\n        }\n      },\n    }\n  }\n\n  // No browser storage.\n  return {\n    get: (file, cb) => {\n      cb(null, root)\n    },\n    put: (file, data, cb) => {\n      cb(null)\n    },\n    list: cb => {\n      cb(\"!\")\n      cb()\n    },\n  }\n}\n\n// Store provides get and put methods that can access radisk.\nconst Store = opt => {\n  if (!utils.obj.is(opt)) opt = {}\n  opt.file = String(opt.file || \"radata\")\n  if (!opt.store) opt.store = fileSystem(opt)\n  const radisk = Radisk(opt)\n\n  return {\n    get: (lex, cb) => {\n      if (!lex) {\n        cb(\"lex required\")\n        return\n      }\n\n      var soul = lex[\"#\"]\n      var key = lex[\".\"] || \"\"\n      var node\n      const each = (value, key) => {\n        if (!node) node = {_: {\"#\": soul, \">\": {}}}\n        node[key] = value[0]\n        node._[\">\"][key] = value[1]\n      }\n\n      radisk(soul + enq + key, (err, value) => {\n        let graph\n        if (utils.obj.is(value)) {\n          Radix.map(value, each)\n          if (!node) each(value, key)\n          graph = {[soul]: node}\n        } else if (value) {\n          each(value, key)\n          graph = {[soul]: node}\n        }\n        cb(err, graph)\n      })\n    },\n    put: (graph, cb) => {\n      if (!graph) {\n        cb(\"graph required\")\n        return\n      }\n\n      var count = 0\n      const ack = err => {\n        count--\n        if (ack.err) return\n\n        ack.err = err\n        if (ack.err) {\n          cb(ack.err)\n          return\n        }\n\n        if (count === 0) cb(null)\n      }\n\n      Object.keys(graph).forEach(soul => {\n        var node = graph[soul]\n        Object.keys(node).forEach(key => {\n          if (key === \"_\") return\n\n          count++\n          let value = node[key]\n          let state = node._[\">\"][key]\n          radisk(soul + enq + key, [value, state], ack)\n        })\n      })\n    },\n  }\n}\n\nexport default Store\n", "import Dup from \"./dup.js\"\nimport Get from \"./get.js\"\nimport Ham from \"./ham.js\"\nimport Store from \"./store.js\"\nimport * as utils from \"./utils.js\"\n\nconst isNode = typeof document === \"undefined\"\n\nconst wsModule = isNode ? await import(\"ws\") : undefined\n\nif (typeof globalThis.WebSocket === \"undefined\") {\n  globalThis.WebSocket = wsModule?.WebSocket\n}\n\n// ASCII character for enquiry.\nconst enq = String.fromCharCode(5)\n\n// Wire starts a websocket client or server and returns get and put methods\n// for access to the wire spec and storage.\nconst Wire = opt => {\n  if (!utils.obj.is(opt)) opt = {}\n\n  const dup = Dup(opt.maxAge)\n  const store = Store(opt)\n  const graph = {}\n  const queue = {}\n  const listen = {}\n\n  const get = (msg, send) => {\n    const ack = Get(msg.get, graph)\n    if (ack) {\n      send(\n        JSON.stringify({\n          \"#\": dup.track(utils.text.random(9)),\n          \"@\": msg[\"#\"],\n          put: ack,\n        }),\n      )\n    } else {\n      store.get(msg.get, (err, ack) => {\n        send(\n          JSON.stringify({\n            \"#\": dup.track(utils.text.random(9)),\n            \"@\": msg[\"#\"],\n            put: ack,\n            err: err,\n          }),\n        )\n      })\n    }\n  }\n\n  const put = (msg, send) => {\n    // Store updates returned from Ham.mix and defer updates if required.\n    const update = Ham.mix(msg.put, graph, listen)\n    store.put(update.now, err => {\n      send(\n        JSON.stringify({\n          \"#\": dup.track(utils.text.random(9)),\n          \"@\": msg[\"#\"],\n          err: err,\n        }),\n      )\n    })\n    if (update.wait !== 0) {\n      setTimeout(() => put({put: update.defer}, send), update.wait)\n    }\n  }\n\n  const api = send => {\n    return {\n      get: (lex, cb, opt) => {\n        if (!cb) return\n\n        if (!utils.obj.is(opt)) opt = {}\n        const ack = Get(lex, graph)\n        if (ack) {\n          cb({put: ack})\n          return\n        }\n\n        store.get(lex, (err, ack) => {\n          if (ack) {\n            cb({put: ack, err: err})\n            return\n          }\n\n          if (err) console.log(err)\n\n          const track = utils.text.random(9)\n          queue[track] = cb\n          send(\n            JSON.stringify({\n              \"#\": dup.track(track),\n              get: lex,\n            }),\n          )\n          // Respond to callback with null if no response.\n          setTimeout(() => {\n            const cb = queue[track]\n            if (cb) {\n              const id = lex[\"#\"]\n              const ack = {[id]: null}\n              if (lex[\".\"]) ack[id] = {[lex[\".\"]]: null}\n              cb({put: ack})\n              delete queue[track]\n            }\n          }, opt.wait || 100)\n        })\n      },\n      put: (data, cb) => {\n        // Deferred updates are only stored using wire spec, they're ignored\n        // here using the api. This is ok because correct timestamps should be\n        // used whereas wire spec needs to handle clock skew.\n        const update = Ham.mix(data, graph, listen)\n        store.put(update.now, cb)\n        // Also put data on the wire spec.\n        // TODO: Note that this means all clients now receive all updates, so\n        // need to filter what should be stored, both in graph and on disk.\n        send(\n          JSON.stringify({\n            \"#\": dup.track(utils.text.random(9)),\n            put: data,\n          }),\n        )\n      },\n      on: (lex, cb) => {\n        if (!cb) return\n\n        let id = lex[\"#\"]\n        if (!id) return\n\n        if (lex[\".\"]) id += enq + lex[\".\"]\n        if (listen[id]) {\n          if (!listen[id].includes(cb)) listen[id].push(cb)\n        } else {\n          listen[id] = [cb]\n        }\n      },\n      off: (lex, cb) => {\n        let id = lex[\"#\"]\n        if (!id) return\n\n        if (lex[\".\"]) id += enq + lex[\".\"]\n        if (!listen[id]) return\n\n        if (cb) {\n          if (listen[id].includes(cb)) {\n            listen[id].splice(listen[id].indexOf(cb), 1)\n          }\n        } else {\n          // Remove all callbacks when none provided.\n          delete listen[id]\n        }\n      },\n    }\n  }\n\n  if (isNode) {\n    let wss = opt.wss\n    // Node's websocket server provides clients as an array, whereas\n    // mock-sockets provides clients as a function that returns an array.\n    let clients = () => wss.clients()\n    if (!wss) {\n      wss = new wsModule.WebSocketServer({port: 8080})\n      clients = () => wss.clients\n    }\n\n    const send = (data, isBinary) => {\n      clients().forEach(client => {\n        if (client.readyState === WebSocket.OPEN) {\n          client.send(data, {binary: isBinary})\n        }\n      })\n    }\n    wss.on(\"connection\", ws => {\n      ws.on(\"error\", console.error)\n\n      ws.on(\"message\", (data, isBinary) => {\n        const msg = JSON.parse(data)\n        if (dup.check(msg[\"#\"])) return\n\n        dup.track(msg[\"#\"])\n        if (msg.get) get(msg, send)\n        if (msg.put) put(msg, send)\n        send(data, isBinary)\n\n        const id = msg[\"@\"]\n        const cb = queue[id]\n        if (cb) {\n          delete msg[\"#\"]\n          delete msg[\"@\"]\n          cb(msg)\n\n          delete queue[id]\n        }\n      })\n    })\n    return api(send)\n  }\n\n  let ws = new WebSocket(\"ws://localhost:8080\")\n  const send = data => {\n    if (!ws || ws.readyState !== WebSocket.OPEN) {\n      console.log(\"websocket not available\")\n      return\n    }\n\n    ws.send(data)\n  }\n  const start = () => {\n    if (!ws) ws = new WebSocket(\"ws://localhost:8080\")\n    ws.onclose = c => {\n      ws = null\n      setTimeout(start, Math.floor(Math.random() * 5000))\n    }\n    ws.onerror = e => {\n      console.error(e)\n    }\n    ws.onmessage = m => {\n      const msg = JSON.parse(m.data)\n      if (dup.check(msg[\"#\"])) return\n\n      dup.track(msg[\"#\"])\n      if (msg.get) get(msg, send)\n      if (msg.put) put(msg, send)\n      send(m.data)\n\n      const id = msg[\"@\"]\n      const cb = queue[id]\n      if (cb) {\n        delete msg[\"#\"]\n        delete msg[\"@\"]\n        cb(msg)\n\n        delete queue[id]\n      }\n    }\n  }\n\n  start()\n  return api(send)\n}\n\nexport default Wire\n", "import * as utils from \"./utils.js\"\nimport Wire from \"./wire.js\"\n\nconst Holster = opt => {\n  const wire = Wire(opt)\n  // Map callbacks since the user's callback is not passed to wire.on.\n  const map = new Map()\n  // Allow concurrent calls to the api by storing each context.\n  const allctx = new Map()\n\n  const ok = data => {\n    return (\n      data === null ||\n      data === true ||\n      data === false ||\n      typeof data === \"string\" ||\n      utils.rel.is(data) ||\n      utils.num.is(data)\n    )\n  }\n\n  // check returns true if data is ok to add to a graph, an error string if\n  // the data can't be converted, and the keys on the data object otherwise.\n  const check = data => {\n    if (ok(data)) return true\n\n    if (utils.obj.is(data)) {\n      const keys = []\n      for (const [key, value] of Object.entries(data)) {\n        if (key === \"_\") {\n          return \"error underscore cannot be used as an item name\"\n        }\n        if (utils.obj.is(value) || ok(value)) {\n          keys.push(key)\n          continue\n        }\n        return `error {${key}:${value}} cannot be converted to graph`\n      }\n      if (keys.length !== 0) return keys\n    }\n    return `error ${data} cannot be converted to a graph`\n  }\n\n  // graph converts objects to graph format with updated states.\n  const graph = (soul, data, g) => {\n    if (!g) g = {[soul]: {_: {\"#\": soul, \">\": {}}}}\n    else g[soul] = {_: {\"#\": soul, \">\": {}}}\n\n    for (const [key, value] of Object.entries(data)) {\n      g[soul][key] = value\n      g[soul]._[\">\"][key] = Date.now()\n    }\n    return g\n  }\n\n  const api = ctxid => {\n    const get = (lex, soul, ack) => {\n      wire.get(utils.obj.put(lex, \"#\", soul), async msg => {\n        if (msg.err) console.log(msg.err)\n        if (msg.put && msg.put[soul]) {\n          delete msg.put[soul]._\n          // Resolve any rels on the node before returning to the user.\n          for (const key of Object.keys(msg.put[soul])) {\n            const id = utils.rel.is(msg.put[soul][key])\n            if (id) {\n              const data = await new Promise(res => {\n                const _ctxid = utils.text.random()\n                allctx.set(_ctxid, {chain: [{item: null, soul: id}]})\n                api(_ctxid).next(null, res)\n              })\n              msg.put[soul][key] = data\n            }\n          }\n          ack(msg.put[soul])\n        } else {\n          // No data callback.\n          ack(null)\n        }\n      })\n    }\n\n    const done = data => {\n      const ctx = allctx.get(ctxid)\n      if (ctx && typeof ctx.cb !== \"undefined\") ctx.cb(data)\n      else if (data) console.log(data)\n      // A context updated by \"on\" should only be removed by \"off\".\n      if (!ctx.on) allctx.delete(ctxid)\n    }\n\n    const resolve = (request, cb) => {\n      const get = request && typeof request.get !== \"undefined\"\n      const put = request && typeof request.put !== \"undefined\"\n      const on = request && typeof request.on !== \"undefined\"\n      const off = request && typeof request.off !== \"undefined\"\n\n      let found = false\n      const ctx = allctx.get(ctxid)\n      for (var i = 1; i < ctx.chain.length; i++) {\n        if (ctx.chain[i].soul !== null) continue\n\n        found = true\n        break\n      }\n\n      if (found) {\n        // Found a soul that needs resolving, need the previous context\n        // (ie the parent node) to find a soul relation for it.\n        const {item, soul} = ctx.chain[i - 1]\n        wire.get({\"#\": soul, \".\": item}, msg => {\n          if (msg.err) {\n            console.log(`error getting ${item} on ${soul}: ${msg.err}`)\n            if (cb) cb(null)\n            return\n          }\n\n          const node = msg.put && msg.put[soul]\n          if (node && typeof node[item] !== \"undefined\") {\n            let id = utils.rel.is(node[item])\n            if (id) {\n              ctx.chain[i].soul = id\n              // Not sure why the map needs to be set rather than just ctx?\n              allctx.set(ctxid, {chain: ctx.chain, cb: ctx.cb})\n              // Call api again using the updated context.\n              if (get) api(ctxid).next(null, request.get, cb)\n              else if (put) api(ctxid).put(request.put, cb)\n              else if (on) api(ctxid).on(cb)\n              else if (off) api(ctxid).off(cb)\n            } else if (get) {\n              // Request was not for a node, return a property on the current\n              // soul.\n              cb(node[item])\n            } else if (put) {\n              // Request was chained before put, so rel doesn't exist yet.\n              id = utils.text.random()\n              const rel = {[item]: utils.rel.ify(id)}\n              wire.put(graph(soul, rel), err => {\n                if (err) {\n                  cb(`error putting ${item} on ${soul}: ${err}`)\n                  return\n                }\n\n                ctx.chain[i].soul = id\n                api(ctxid).put(request.put, cb)\n              })\n            } else if (on) {\n              console.log(`error resolving on for ${item} on ${soul}`)\n              cb(null)\n            } else if (off) {\n              console.log(`error resolving off for ${item} on ${soul}`)\n              if (cb) cb(null)\n            }\n          } else if (put) {\n            cb(`error ${item} not found on ${soul}`)\n          } else {\n            console.log(`error ${item} not found on ${soul}`)\n            if (cb) cb(null)\n          }\n        })\n        // Callback has been passed to next soul lookup or called above, so\n        // return false as the calling code should not continue.\n        return false\n      }\n\n      if (get && ctx.chain[ctx.chain.length - 1].item !== null) {\n        // The context has been resolved but it does not include the requested\n        // node, which requires one more lookup.\n        ctx.chain.push({item: null, soul: null})\n        api(ctxid).next(null, request.get, cb)\n        return false\n      }\n\n      // Return the last context, ie the soul required by the calling code.\n      return ctx.chain[ctx.chain.length - 1]\n    }\n\n    return {\n      get: (key, lex, cb) => {\n        if (typeof lex === \"function\") {\n          cb = lex\n          lex = null\n        }\n        if (key === null || key === \"\" || key === \"_\") {\n          if (cb) cb(null)\n          return\n        }\n\n        ctxid = utils.text.random()\n        // Top level keys are added to a root node so their values don't need\n        // to be objects.\n        allctx.set(ctxid, {chain: [{item: key, soul: \"root\"}], cb: cb})\n        if (!cb) return api(ctxid)\n\n        // When there's a callback need to resolve the context first.\n        const {soul} = resolve({get: lex}, done)\n        if (soul) get(lex, soul, done)\n      },\n      next: (key, lex, cb) => {\n        const ack = data => {\n          cb ? cb(data) : done(data)\n        }\n\n        if (typeof lex === \"function\") {\n          cb = lex\n          lex = null\n        }\n        if (!ctxid) {\n          console.log(\"please provide a key using get(key)\")\n          ack(null)\n          return\n        }\n\n        const ctx = allctx.get(ctxid)\n        // ctx already removed by another chained callback is ok?\n        if (!ctx) return\n\n        if (cb && typeof ctx.cb === \"undefined\") {\n          // This (and ack) allows nested objects to set their own callbacks.\n          ctx.cb = cb\n          cb = null\n        }\n\n        if (key === \"\" || key === \"_\") {\n          ack(null)\n          return\n        }\n\n        // Push the key to the context as it needs a soul lookup.\n        // (null is used to call the api with updated context)\n        if (key !== null) ctx.chain.push({item: key, soul: null})\n        if (!ctx.cb) return api(ctxid)\n\n        // When there's a callback need to resolve the context first.\n        const {soul} = resolve({get: lex}, ack)\n        if (soul) get(lex, soul, ack)\n      },\n      put: (data, cb) => {\n        const ack = err => {\n          cb ? cb(err) : done(err)\n        }\n\n        if (!ctxid) {\n          ack(\"please provide a key using get(key)\")\n          return\n        }\n\n        const ctx = allctx.get(ctxid)\n        // ctx already removed by another chained callback is ok?\n        if (!ctx) return\n\n        if (!ctx.cb) {\n          if (!cb) return\n\n          // This (and ack) allows nested objects to set their own callbacks.\n          ctx.cb = cb\n          cb = null\n        }\n\n        const result = check(data)\n        if (typeof result === \"string\") {\n          // All strings returned from check are errors, cannot continue.\n          ack(result)\n          return\n        }\n\n        // Resolve the current context before putting data.\n        const {item, soul} = resolve({put: data}, ack)\n        if (!soul) return\n\n        if (result === true) {\n          // When result is true data is a property to put on the current soul.\n          // Need to check if item is a rel and also set the node to null. (This\n          // applies for any update from a rel to a property, not just null.)\n          wire.get({\"#\": soul, \".\": item}, async msg => {\n            if (msg.err) {\n              console.log(`error getting ${soul}: ${msg.err}`)\n              return\n            }\n\n            const current = msg.put && msg.put[soul] && msg.put[soul][item]\n            const id = utils.rel.is(current)\n            if (!id) {\n              // Not a rel, can just put the data.\n              wire.put(graph(soul, {[item]: data}), ack)\n              return\n            }\n\n            wire.get({\"#\": id}, async msg => {\n              if (msg.err) {\n                console.log(`error getting ${id}: ${msg.err}`)\n                return\n              }\n\n              if (!msg.put || !msg.put[id]) {\n                console.log(`error ${id} not found`)\n                return\n              }\n\n              delete msg.put[id]._\n              // null each of the properties on the node before putting data.\n              for (const key of Object.keys(msg.put[id])) {\n                const err = await new Promise(res => {\n                  const _ctxid = utils.text.random()\n                  allctx.set(_ctxid, {chain: [{item: key, soul: id}]})\n                  api(_ctxid).put(null, res)\n                })\n                if (err) {\n                  ack(err)\n                  return\n                }\n              }\n              wire.put(graph(soul, {[item]: data}), ack)\n            })\n          })\n          return\n        }\n\n        // Otherwise put the data using the keys returned in result.\n        // Need to check if a rel has already been added on the current node.\n        wire.get({\"#\": soul, \".\": item}, async msg => {\n          if (msg.err) {\n            ack(`error getting ${soul}: ${msg.err}`)\n            return\n          }\n\n          const current = msg.put && msg.put[soul] && msg.put[soul][item]\n          const id = utils.rel.is(current)\n          if (!id) {\n            // The current rel doesn't exist, so add it first.\n            const rel = {[item]: utils.rel.ify(utils.text.random())}\n            wire.put(graph(soul, rel), err => {\n              if (err) {\n                ack(`error putting ${item} on ${soul}: ${err}`)\n              } else {\n                const _ctxid = utils.text.random()\n                const chain = [{item: item, soul: soul}]\n                // Pass the previous context's callback on here.\n                allctx.set(_ctxid, {chain: chain, cb: ctx.cb})\n                api(_ctxid).put(data)\n              }\n            })\n            return\n          }\n\n          let put = false\n          const update = {}\n          for (const key of result) {\n            const err = await new Promise(res => {\n              if (utils.obj.is(data[key])) {\n                // Use the current rel as the context for nested objects.\n                const _ctxid = utils.text.random()\n                allctx.set(_ctxid, {chain: [{item: key, soul: id}]})\n                api(_ctxid).put(data[key], res)\n              } else {\n                put = true\n                // Group other properties into one update.\n                update[key] = data[key]\n                res(null)\n              }\n            })\n            if (err) {\n              ack(err)\n              return\n            }\n          }\n          if (put) wire.put(graph(id, update), ack)\n          else ack()\n        })\n      },\n      on: cb => {\n        if (!cb) return\n\n        if (!ctxid) {\n          console.log(\"please provide a key using get(key)\")\n          cb(null)\n          return\n        }\n\n        // Resolve the current context before adding event listener.\n        const {item, soul} = resolve({on: true}, cb)\n        if (!soul) return\n\n        // Flag that this context is set from on and shouldn't be removed.\n        allctx.set(ctxid, {chain: [{item: item, soul: soul}], on: true})\n        // Map the user's callback because it can also be passed to off,\n        // so need a reference to it to compare them.\n        map.set(cb, () => api(ctxid).next(null, cb))\n        // Check if item is a rel and add event listener for the node.\n        wire.get({\"#\": soul, \".\": item}, async msg => {\n          if (msg.err) {\n            console.log(`error getting ${soul}: ${msg.err}`)\n            return\n          }\n\n          const current = msg.put && msg.put[soul] && msg.put[soul][item]\n          const id = utils.rel.is(current)\n          if (id) wire.on({\"#\": id}, map.get(cb))\n          else wire.on({\"#\": soul, \".\": item}, map.get(cb))\n        })\n      },\n      off: cb => {\n        if (!ctxid) {\n          console.log(\"please provide a key using get(key)\")\n          if (cb) cb(null)\n          return\n        }\n\n        // Resolve the current context before removing event listener.\n        const {item, soul} = resolve({off: true}, cb)\n        if (!soul) return\n\n        // Check if item is a rel and remove event listener for the node.\n        wire.get({\"#\": soul, \".\": item}, async msg => {\n          if (msg.err) {\n            console.log(`error getting ${soul}: ${msg.err}`)\n            return\n          }\n\n          const current = msg.put && msg.put[soul] && msg.put[soul][item]\n          const id = utils.rel.is(current)\n          if (id) wire.off({\"#\": id}, map.get(cb))\n          else wire.off({\"#\": soul, \".\": item}, map.get(cb))\n          map.delete(cb)\n          allctx.delete(ctxid)\n        })\n      },\n      // Allow the wire spec to be used via holster.\n      wire: wire,\n    }\n  }\n  return api()\n}\n\nexport default Holster\n"],
  "mappings": "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",
  "names": ["num", "n", "obj", "o", "list", "cb", "keys", "result", "key", "value", "map_soul", "soul", "rel", "text", "length", "s", "c", "i", "Dup", "maxAge", "dup", "id", "now", "dup_default", "Get", "lex", "graph", "soul", "key", "node", "value", "get_default", "enq", "Ham", "state", "currentState", "value", "currentValue", "change", "graph", "listen", "machine", "now", "defer", "wait", "soul", "node", "updated", "key", "skew", "id", "cb", "ham_default", "group", "record", "Radix", "radix", "keys", "value", "tree", "tmp", "key", "max", "noValue", "found", "obj", "hasValue", "hasKey", "j", "matchingKey", "replace", "map", "cb", "opt", "pre", "u", "i", "radix_default", "etx", "enq", "unit", "Radisk", "opt", "u", "cache", "radisk", "key", "value", "cb", "radix_default", "batch", "i", "err", "rad", "save", "tree", "file", "start", "end", "disk", "write", "k", "pre", "enc", "name", "soul", "read", "parse", "data", "tmp", "a", "c", "o", "state", "current", "text", "rel", "num", "obj", "n", "previous", "radisk_default", "isNode", "fs", "enq", "unit", "root", "fileSystem", "opt", "dir", "file", "cb", "err", "data", "random", "tmp", "files", "db", "o", "event", "req", "Store", "obj", "radisk", "radisk_default", "lex", "soul", "key", "node", "each", "value", "graph", "radix_default", "count", "ack", "state", "store_default", "isNode", "wsModule", "enq", "Wire", "opt", "obj", "dup", "dup_default", "store", "store_default", "graph", "queue", "listen", "get", "msg", "send", "ack", "get_default", "text", "err", "put", "update", "ham_default", "api", "lex", "cb", "track", "id", "data", "wss", "clients", "isBinary", "client", "ws", "start", "c", "e", "m", "wire_default", "Holster", "opt", "wire", "wire_default", "map", "allctx", "ok", "data", "rel", "num", "check", "obj", "keys", "key", "value", "graph", "soul", "g", "api", "ctxid", "get", "lex", "ack", "msg", "id", "res", "_ctxid", "text", "done", "ctx", "resolve", "request", "cb", "put", "on", "off", "found", "i", "item", "node", "err", "result", "current", "chain", "update", "holster_default"]
}
