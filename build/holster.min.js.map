{"version":3,"file":"holster.min.js","mappings":"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","sources":["webpack://Holster/./node_modules/browser-or-node/dist/index.js","webpack://Holster/./node_modules/ws/browser.js","webpack://Holster/./src/dup.js","webpack://Holster/./src/get.js","webpack://Holster/./src/ham.js","webpack://Holster/./src/holster.js","webpack://Holster/./src/radisk.js","webpack://Holster/./src/radix.js","webpack://Holster/./src/store.js","webpack://Holster/./src/utils.js","webpack://Holster/./src/wire.js","webpack://Holster/webpack/bootstrap","webpack://Holster/webpack/startup"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  isBrowser: () => isBrowser,\n  isBun: () => isBun,\n  isDeno: () => isDeno,\n  isJsDom: () => isJsDom,\n  isNode: () => isNode,\n  isWebWorker: () => isWebWorker\n});\nmodule.exports = __toCommonJS(src_exports);\nvar isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\nvar isNode = (\n  // @ts-expect-error\n  typeof process !== \"undefined\" && // @ts-expect-error\n  process.versions != null && // @ts-expect-error\n  process.versions.node != null\n);\nvar isWebWorker = typeof self === \"object\" && self.constructor && self.constructor.name === \"DedicatedWorkerGlobalScope\";\nvar isJsDom = typeof window !== \"undefined\" && window.name === \"nodejs\" || typeof navigator !== \"undefined\" && \"userAgent\" in navigator && typeof navigator.userAgent === \"string\" && (navigator.userAgent.includes(\"Node.js\") || navigator.userAgent.includes(\"jsdom\"));\nvar isDeno = (\n  // @ts-expect-error\n  typeof Deno !== \"undefined\" && // @ts-expect-error\n  typeof Deno.version !== \"undefined\" && // @ts-expect-error\n  typeof Deno.version.deno !== \"undefined\"\n);\nvar isBun = typeof process !== \"undefined\" && process.versions != null && process.versions.bun != null;\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  isBrowser,\n  isBun,\n  isDeno,\n  isJsDom,\n  isNode,\n  isWebWorker\n});\n","'use strict';\n\nmodule.exports = function () {\n  throw new Error(\n    'ws does not work in the browser. Browser clients must use the native ' +\n      'WebSocket object'\n  );\n};\n","const Dup = maxAge => {\n  // Allow maxAge to be passed in as tests wait on the setTimeout.\n  if (!maxAge) maxAge = 9000\n  const dup = {store: {}}\n  dup.check = id => (dup.store[id] ? dup.track(id) : false)\n  dup.track = id => {\n    // Keep the liveliness of the message up while it is being received.\n    dup.store[id] = Date.now()\n    if (!dup.expiry) {\n      dup.expiry = setTimeout(() => {\n        const now = Date.now()\n        Object.keys(dup.store).forEach(id => {\n          if (now - dup.store[id] > maxAge) delete dup.store[id]\n        })\n        dup.expiry = null\n      }, maxAge)\n    }\n    return id\n  }\n  return dup\n}\n\nmodule.exports = Dup\n","const Get = (lex, graph) => {\n  const soul = lex[\"#\"]\n  const key = lex[\".\"]\n  var node = graph[soul]\n\n  // Can only return a node if a key is provided, because the graph may not\n  // have all the keys populated for a given soul. This is because Ham.mix\n  // only adds incoming changes to the graph.\n  if (!node || !key) return\n\n  let value = node[key]\n  if (!value) return\n\n  node = {_: node._, [key]: value}\n  node._[\">\"] = {[key]: node._[\">\"][key]}\n  return {[soul]: node}\n}\n\nmodule.exports = Get\n","// ASCII character for enquiry.\nconst enq = String.fromCharCode(5)\n\n// state and value are the incoming changes.\n// currentState and currentValue are the current graph data.\nconst Ham = (state, currentState, value, currentValue) => {\n  if (state < currentState) return {historical: true}\n\n  if (state > currentState) return {incoming: true}\n\n  // state is equal to currentState, lexically compare to resolve conflict.\n  if (typeof value !== \"string\") {\n    value = JSON.stringify(value) || \"\"\n  }\n  if (typeof currentValue !== \"string\") {\n    currentValue = JSON.stringify(currentValue) || \"\"\n  }\n  // No update required.\n  if (value === currentValue) return {state: true}\n\n  // Keep the current value.\n  if (value < currentValue) return {current: true}\n\n  // Otherwise update using the incoming value.\n  return {incoming: true}\n}\n\nHam.mix = (change, graph, listen) => {\n  var machine = Date.now()\n  var now = {}\n  var defer = {}\n  let wait = 0\n\n  Object.keys(change).forEach(soul => {\n    const node = change[soul]\n    let updated = false\n    Object.keys(node).forEach(key => {\n      if (key === \"_\") return\n\n      const value = node[key]\n      const state = node._[\">\"][key]\n      const currentValue = (graph[soul] || {})[key]\n      const currentState = (graph[soul] || {_: {\">\": {}}})._[\">\"][key] || 0\n\n      // Defer the update if ahead of machine time.\n      const skew = state - machine\n      if (skew > 0) {\n        // Ignore update if ahead by more than 24 hours.\n        if (skew > 86400000) return\n\n        // Wait the shortest difference before trying the updates again.\n        if (wait === 0 || skew < wait) wait = skew\n        if (!defer[soul]) defer[soul] = {_: {\"#\": soul, \">\": {}}}\n        defer[soul][key] = value\n        defer[soul]._[\">\"][key] = state\n      } else {\n        const result = Ham(state, currentState, value, currentValue)\n        if (result.incoming) {\n          if (!now[soul]) now[soul] = {_: {\"#\": soul, \">\": {}}}\n          // TODO: graph should not just grow indefintitely in memory.\n          // Need to have a max size after which start dropping the oldest state\n          // Do something similar to Dup which can handle deletes?\n          if (!graph[soul]) graph[soul] = {_: {\"#\": soul, \">\": {}}}\n          graph[soul][key] = now[soul][key] = value\n          graph[soul]._[\">\"][key] = now[soul]._[\">\"][key] = state\n          // Call event listeners for update on key, mix is called before\n          // put has finished so wait for what could be multiple nested\n          // updates on a node.\n          setTimeout(() => {\n            const id = soul + enq + key\n            if (listen[id]) listen[id].forEach(cb => cb())\n          }, 100)\n          updated = true\n        }\n      }\n    })\n    // Call event listeners for update on soul.\n    if (updated && listen[soul])\n      setTimeout(() => {\n        listen[soul].forEach(cb => cb())\n      }, 100)\n  })\n  return {now: now, defer: defer, wait: wait}\n}\n\nmodule.exports = Ham\n","const utils = require(\"./utils\")\nconst Wire = require(\"./wire\")\n\nconst Holster = opt => {\n  const wire = Wire(opt)\n  // Map callbacks since the user's callback is not passed to wire.on.\n  const map = new Map()\n  // Allow concurrent calls to the api by storing each context.\n  const allctx = new Map()\n\n  const ok = data => {\n    return (\n      data === null ||\n      data === true ||\n      data === false ||\n      typeof data === \"string\" ||\n      utils.rel.is(data) ||\n      utils.num.is(data)\n    )\n  }\n\n  // check returns true if data is ok to add to a graph, an error string if\n  // the data can't be converted, and the keys on the data object otherwise.\n  const check = data => {\n    if (ok(data)) return true\n\n    if (utils.obj.is(data)) {\n      const keys = []\n      for (const [key, value] of Object.entries(data)) {\n        if (key === \"_\") {\n          return \"error underscore cannot be used as an item name\"\n        }\n        if (utils.obj.is(value) || ok(value)) {\n          keys.push(key)\n          continue\n        }\n        return `error {${key}:${value}} cannot be converted to graph`\n      }\n      if (keys.length !== 0) return keys\n    }\n    return `error ${data} cannot be converted to a graph`\n  }\n\n  // graph converts objects to graph format with updated states.\n  const graph = (soul, data, g) => {\n    if (!g) g = {[soul]: {_: {\"#\": soul, \">\": {}}}}\n    else g[soul] = {_: {\"#\": soul, \">\": {}}}\n\n    for (const [key, value] of Object.entries(data)) {\n      g[soul][key] = value\n      g[soul]._[\">\"][key] = Date.now()\n    }\n    return g\n  }\n\n  const api = ctxid => {\n    const get = (lex, soul, ack) => {\n      wire.get(utils.obj.put(lex, \"#\", soul), async msg => {\n        if (msg.err) console.log(msg.err)\n        if (msg.put && msg.put[soul]) {\n          delete msg.put[soul]._\n          // Resolve any rels on the node before returning to the user.\n          for (const key of Object.keys(msg.put[soul])) {\n            const id = utils.rel.is(msg.put[soul][key])\n            if (id) {\n              const data = await new Promise(res => {\n                const _ctxid = utils.text.random()\n                allctx.set(_ctxid, {chain: [{item: null, soul: id}]})\n                api(_ctxid).then(null, res)\n              })\n              msg.put[soul][key] = data\n            }\n          }\n          ack(msg.put[soul])\n        } else {\n          // No data callback.\n          ack(null)\n        }\n      })\n    }\n\n    const done = data => {\n      const ctx = allctx.get(ctxid)\n      if (ctx && typeof ctx.cb !== \"undefined\") ctx.cb(data)\n      else if (data) console.log(data)\n      // A context updated by \"on\" should only be removed by \"off\".\n      if (!ctx.on) allctx.delete(ctxid)\n    }\n\n    const resolve = (request, cb) => {\n      const get = request && typeof request.get !== \"undefined\"\n      const put = request && typeof request.put !== \"undefined\"\n      const on = request && typeof request.on !== \"undefined\"\n      const off = request && typeof request.off !== \"undefined\"\n\n      let found = false\n      const ctx = allctx.get(ctxid)\n      for (var i = 1; i < ctx.chain.length; i++) {\n        if (ctx.chain[i].soul !== null) continue\n\n        found = true\n        break\n      }\n\n      if (found) {\n        // Found a soul that needs resolving, need the previous context\n        // (ie the parent node) to find a soul relation for it.\n        const {item, soul} = ctx.chain[i - 1]\n        wire.get({\"#\": soul, \".\": item}, msg => {\n          if (msg.err) {\n            console.log(`error getting ${item} on ${soul}: ${msg.err}`)\n            if (cb) cb(null)\n            return\n          }\n\n          const node = msg.put && msg.put[soul]\n          if (node && typeof node[item] !== \"undefined\") {\n            let id = utils.rel.is(node[item])\n            if (id) {\n              ctx.chain[i].soul = id\n              // Not sure why the map needs to be set rather than just ctx?\n              allctx.set(ctxid, {chain: ctx.chain, cb: ctx.cb})\n              // Call api again using the updated context.\n              if (get) api(ctxid).then(null, request.get, cb)\n              else if (put) api(ctxid).put(request.put, cb)\n              else if (on) api(ctxid).on(cb)\n              else if (off) api(ctxid).off(cb)\n            } else if (get) {\n              // Request was not for a node, return a property on the current\n              // soul.\n              cb(node[item])\n            } else if (put) {\n              // Request was chained before put, so rel doesn't exist yet.\n              id = utils.text.random()\n              const rel = {[item]: utils.rel.ify(id)}\n              wire.put(graph(soul, rel), err => {\n                if (err) {\n                  cb(`error putting ${item} on ${soul}: ${err}`)\n                  return\n                }\n\n                ctx.chain[i].soul = id\n                api(ctxid).put(request.put, cb)\n              })\n            } else if (on) {\n              console.log(`error resolving on for ${item} on ${soul}`)\n              cb(null)\n            } else if (off) {\n              console.log(`error resolving off for ${item} on ${soul}`)\n              if (cb) cb(null)\n            }\n          } else if (put) {\n            cb(`error ${item} not found on ${soul}`)\n          } else {\n            console.log(`error ${item} not found on ${soul}`)\n            if (cb) cb(null)\n          }\n        })\n        // Callback has been passed to next soul lookup or called above, so\n        // return false as the calling code should not continue.\n        return false\n      }\n\n      if (get && ctx.chain[ctx.chain.length - 1].item !== null) {\n        // The context has been resolved but it does not include the requested\n        // node, which requires one more lookup.\n        ctx.chain.push({item: null, soul: null})\n        api(ctxid).then(null, request.get, cb)\n        return false\n      }\n\n      // Return the last context, ie the soul required by the calling code.\n      return ctx.chain[ctx.chain.length - 1]\n    }\n\n    return {\n      get: (key, lex, cb) => {\n        if (typeof lex === \"function\") {\n          cb = lex\n          lex = null\n        }\n        if (key === null || key === \"\" || key === \"_\") {\n          if (cb) cb(null)\n          return\n        }\n\n        ctxid = utils.text.random()\n        // Top level keys are added to a root node so their values don't need\n        // to be objects.\n        allctx.set(ctxid, {chain: [{item: key, soul: \"root\"}], cb: cb})\n        if (!cb) return api(ctxid)\n\n        // When there's a callback need to resolve the context first.\n        const {soul} = resolve({get: lex}, done)\n        if (soul) get(lex, soul, done)\n      },\n      then: (key, lex, cb) => {\n        const ack = data => {\n          cb ? cb(data) : done(data)\n        }\n\n        if (typeof lex === \"function\") {\n          cb = lex\n          lex = null\n        }\n        if (!ctxid) {\n          console.log(\"please provide a key using get(key)\")\n          ack(null)\n          return\n        }\n\n        const ctx = allctx.get(ctxid)\n        // ctx already removed by another chained callback is ok?\n        if (!ctx) return\n\n        if (cb && typeof ctx.cb === \"undefined\") {\n          // This (and ack) allows nested objects to set their own callbacks.\n          ctx.cb = cb\n          cb = null\n        }\n\n        if (key === \"\" || key === \"_\") {\n          ack(null)\n          return\n        }\n\n        // Push the key to the context as it needs a soul lookup.\n        // (null is used to call the api with updated context)\n        if (key !== null) ctx.chain.push({item: key, soul: null})\n        if (!ctx.cb) return api(ctxid)\n\n        // When there's a callback need to resolve the context first.\n        const {soul} = resolve({get: lex}, ack)\n        if (soul) get(lex, soul, ack)\n      },\n      put: (data, cb) => {\n        const ack = err => {\n          cb ? cb(err) : done(err)\n        }\n\n        if (!ctxid) {\n          ack(\"please provide a key using get(key)\")\n          return\n        }\n\n        const ctx = allctx.get(ctxid)\n        // ctx already removed by another chained callback is ok?\n        if (!ctx) return\n\n        if (!ctx.cb) {\n          if (!cb) return\n\n          // This (and ack) allows nested objects to set their own callbacks.\n          ctx.cb = cb\n          cb = null\n        }\n\n        const result = check(data)\n        if (typeof result === \"string\") {\n          // All strings returned from check are errors, cannot continue.\n          ack(result)\n          return\n        }\n\n        // Resolve the current context before putting data.\n        const {item, soul} = resolve({put: data}, ack)\n        if (!soul) return\n\n        if (result === true) {\n          // When result is true data is a property to put on the current soul.\n          // Need to check if item is a rel and also set the node to null. (This\n          // applies for any update from a rel to a property, not just null.)\n          wire.get({\"#\": soul, \".\": item}, async msg => {\n            if (msg.err) {\n              console.log(`error getting ${soul}: ${msg.err}`)\n              return\n            }\n\n            const current = msg.put && msg.put[soul] && msg.put[soul][item]\n            const id = utils.rel.is(current)\n            if (!id) {\n              // Not a rel, can just put the data.\n              wire.put(graph(soul, {[item]: data}), ack)\n              return\n            }\n\n            wire.get({\"#\": id}, async msg => {\n              if (msg.err) {\n                console.log(`error getting ${id}: ${msg.err}`)\n                return\n              }\n\n              if (!msg.put || !msg.put[id]) {\n                console.log(`error ${id} not found`)\n                return\n              }\n\n              delete msg.put[id]._\n              // null each of the properties on the node before putting data.\n              for (const key of Object.keys(msg.put[id])) {\n                const err = await new Promise(res => {\n                  const _ctxid = utils.text.random()\n                  allctx.set(_ctxid, {chain: [{item: key, soul: id}]})\n                  api(_ctxid).put(null, res)\n                })\n                if (err) {\n                  ack(err)\n                  return\n                }\n              }\n              wire.put(graph(soul, {[item]: data}), ack)\n            })\n          })\n          return\n        }\n\n        // Otherwise put the data using the keys returned in result.\n        // Need to check if a rel has already been added on the current node.\n        wire.get({\"#\": soul, \".\": item}, async msg => {\n          if (msg.err) {\n            ack(`error getting ${soul}: ${msg.err}`)\n            return\n          }\n\n          const current = msg.put && msg.put[soul] && msg.put[soul][item]\n          const id = utils.rel.is(current)\n          if (!id) {\n            // The current rel doesn't exist, so add it first.\n            const rel = {[item]: utils.rel.ify(utils.text.random())}\n            wire.put(graph(soul, rel), err => {\n              if (err) {\n                ack(`error putting ${item} on ${soul}: ${err}`)\n              } else {\n                const _ctxid = utils.text.random()\n                const chain = [{item: item, soul: soul}]\n                // Pass the previous context's callback on here.\n                allctx.set(_ctxid, {chain: chain, cb: ctx.cb})\n                api(_ctxid).put(data)\n              }\n            })\n            return\n          }\n\n          let put = false\n          const update = {}\n          for (const key of result) {\n            const err = await new Promise(res => {\n              if (utils.obj.is(data[key])) {\n                // Use the current rel as the context for nested objects.\n                const _ctxid = utils.text.random()\n                allctx.set(_ctxid, {chain: [{item: key, soul: id}]})\n                api(_ctxid).put(data[key], res)\n              } else {\n                put = true\n                // Group other properties into one update.\n                update[key] = data[key]\n                res(null)\n              }\n            })\n            if (err) {\n              ack(err)\n              return\n            }\n          }\n          if (put) wire.put(graph(id, update), ack)\n          else ack()\n        })\n      },\n      on: cb => {\n        if (!cb) return\n\n        if (!ctxid) {\n          console.log(\"please provide a key using get(key)\")\n          cb(null)\n          return\n        }\n\n        // Resolve the current context before adding event listener.\n        const {item, soul} = resolve({on: true}, cb)\n        if (!soul) return\n\n        // Flag that this context is set from on and shouldn't be removed.\n        allctx.set(ctxid, {chain: [{item: item, soul: soul}], on: true})\n        // Map the user's callback because it can also be passed to off,\n        // so need a reference to it to compare them.\n        map.set(cb, () => api(ctxid).then(null, cb))\n        // Check if item is a rel and add event listener for the node.\n        wire.get({\"#\": soul, \".\": item}, async msg => {\n          if (msg.err) {\n            console.log(`error getting ${soul}: ${msg.err}`)\n            return\n          }\n\n          const current = msg.put && msg.put[soul] && msg.put[soul][item]\n          const id = utils.rel.is(current)\n          if (id) wire.on({\"#\": id}, map.get(cb))\n          else wire.on({\"#\": soul, \".\": item}, map.get(cb))\n        })\n      },\n      off: cb => {\n        if (!ctxid) {\n          console.log(\"please provide a key using get(key)\")\n          if (cb) cb(null)\n          return\n        }\n\n        // Resolve the current context before removing event listener.\n        const {item, soul} = resolve({off: true}, cb)\n        if (!soul) return\n\n        // Check if item is a rel and remove event listener for the node.\n        wire.get({\"#\": soul, \".\": item}, async msg => {\n          if (msg.err) {\n            console.log(`error getting ${soul}: ${msg.err}`)\n            return\n          }\n\n          const current = msg.put && msg.put[soul] && msg.put[soul][item]\n          const id = utils.rel.is(current)\n          if (id) wire.off({\"#\": id}, map.get(cb))\n          else wire.off({\"#\": soul, \".\": item}, map.get(cb))\n          map.delete(cb)\n          allctx.delete(ctxid)\n        })\n      },\n      // Allow the wire spec to be used via holster.\n      wire: wire,\n    }\n  }\n  return api()\n}\n\nmodule.exports = Holster\n","const Radix = require(\"./radix\")\nconst utils = require(\"./utils\")\n\n// ASCII character for end of text.\nconst etx = String.fromCharCode(3)\n// ASCII character for enquiry.\nconst enq = String.fromCharCode(5)\n// ASCII character for unit separator.\nconst unit = String.fromCharCode(31)\n\n// Radisk provides access to a radix tree that is stored in the provided\n// opt.store interface.\nconst Radisk = opt => {\n  var u\n  var cache = null\n\n  if (!opt) opt = {}\n  if (!opt.log) opt.log = console.log\n  if (!opt.batch) opt.batch = 10 * 1000\n  if (!opt.write) opt.write = 1 // Wait time before write in milliseconds.\n  if (!opt.size) opt.size = 1024 * 1024 // File size on disk, default 1MB.\n  if (!opt.store) {\n    opt.log(\n      \"Radisk needs `store` interface with `{get: fn, put: fn, list: fn}`\",\n    )\n    return\n  }\n  if (!opt.store.get) {\n    opt.log(\"Radisk needs `store.get` interface with `(file, cb)`\")\n    return\n  }\n  if (!opt.store.put) {\n    opt.log(\"Radisk needs `store.put` interface with `(file, data, cb)`\")\n    return\n  }\n  if (!opt.store.list) {\n    opt.log(\"Radisk needs a streaming `store.list` interface with `(cb)`\")\n    return\n  }\n\n  // Any and all storage adapters should:\n  // 1. Because writing to disk takes time, we should batch data to disk.\n  //    This improves performance, and reduces potential disk corruption.\n  // 2. If a batch exceeds a certain number of writes, we should immediately\n  //    write to disk when physically possible. This caps total performance,\n  //    but reduces potential loss.\n  const radisk = (key, value, cb) => {\n    key = \"\" + key\n\n    // If no value is provided then the second parameter is the callback\n    // function. Read value from memory or disk and call callback with it.\n    if (typeof value === \"function\") {\n      cb = value\n      value = radisk.batch(key)\n      if (typeof value !== \"undefined\") {\n        return cb(u, value)\n      }\n\n      if (radisk.thrash.at) {\n        value = radisk.thrash.at(key)\n        if (typeof value !== \"undefined\") {\n          return cb(u, value)\n        }\n      }\n\n      return radisk.read(key, cb)\n    }\n\n    // Otherwise store the value provided.\n    radisk.batch(key, value)\n    if (cb) {\n      radisk.batch.acks.push(cb)\n    }\n    // Don't wait if we have batched too many.\n    if (++radisk.batch.ed >= opt.batch) {\n      return radisk.thrash()\n    }\n\n    // Otherwise wait for more updates before writing.\n    clearTimeout(radisk.batch.timeout)\n    radisk.batch.timeout = setTimeout(radisk.thrash, opt.write)\n  }\n\n  radisk.batch = Radix()\n  radisk.batch.acks = []\n  radisk.batch.ed = 0\n\n  radisk.thrash = () => {\n    if (radisk.thrash.ing) {\n      return (radisk.thrash.more = true)\n    }\n\n    clearTimeout(radisk.batch.timeout)\n    radisk.thrash.more = false\n    radisk.thrash.ing = true\n    var batch = (radisk.thrash.at = radisk.batch)\n    radisk.batch = null\n    radisk.batch = Radix()\n    radisk.batch.acks = []\n    radisk.batch.ed = 0\n    let i = 0\n    radisk.save(batch, err => {\n      // This is to ignore multiple callbacks from radisk.save calling\n      // radisk.write? It looks like multiple callbacks will be made if a\n      // file needs to be split.\n      if (++i > 1) return\n\n      if (err) opt.log(err)\n      batch.acks.forEach(cb => cb(err))\n      radisk.thrash.at = null\n      radisk.thrash.ing = false\n      if (radisk.thrash.more) radisk.thrash()\n    })\n  }\n\n  // 1. Find the first radix item in memory\n  // 2. Use that as the starting index in the directory of files\n  // 3. Find the first file that is lexically larger than it\n  // 4. Read the previous file into memory\n  // 5. Scan through in memory radix for all values lexically less than limit\n  // 6. Merge and write all of those to the in-memory file and back to disk\n  // 7. If file is to large then split. More details needed here\n  radisk.save = (rad, cb) => {\n    const save = {\n      find: (tree, key) => {\n        // This is false for any key until save.start is set to an initial key.\n        if (key < save.start) return\n\n        save.start = key\n        opt.store.list(save.lex)\n        return true\n      },\n      lex: file => {\n        if (!file || file > save.start) {\n          save.end = file\n          // ! is used as the first file name as it's the first printable\n          // character, so always matches as lexically less than any node.\n          save.mix(save.file || \"!\", save.start, save.end)\n          return true\n        }\n\n        save.file = file\n      },\n      mix: (file, start, end) => {\n        save.start = save.end = save.file = u\n        radisk.parse(file, (err, disk) => {\n          if (err) return cb(err)\n\n          Radix.map(rad, (value, key) => {\n            if (key < start) return\n\n            if (end && end < key) {\n              save.start = key\n              return save.start\n            }\n\n            disk(key, value)\n          })\n          radisk.write(file, disk, save.next)\n        })\n      },\n      next: err => {\n        if (err) return cb(err)\n\n        if (save.start) return Radix.map(rad, save.find)\n\n        cb(err)\n      },\n    }\n    Radix.map(rad, save.find)\n  }\n\n  radisk.write = (file, rad, cb) => {\n    // Invalidate cache on write.\n    cache = null\n    const write = {\n      text: \"\",\n      count: 0,\n      file: file,\n      each: (value, key, k, pre) => {\n        write.count++\n        var enc =\n          Radisk.encode(pre.length) +\n          \"#\" +\n          Radisk.encode(k) +\n          (typeof value === \"undefined\" ? \"\" : \"=\" + Radisk.encode(value)) +\n          \"\\n\"\n        // Cannot split the file if only have one entry to write.\n        if (write.count > 1 && write.text.length + enc.length > opt.size) {\n          write.text = \"\"\n          // Otherwise split the entries in half.\n          write.limit = Math.ceil(write.count / 2)\n          write.count = 0\n          write.sub = Radix()\n          Radix.map(rad, write.slice)\n          return true\n        }\n\n        write.text += enc\n      },\n      put: () => {\n        opt.store.put(file, write.text, cb)\n      },\n      slice: (value, key) => {\n        if (key < write.file) return\n\n        if (++write.count > write.limit) {\n          var name = write.file\n          // Use only the soul of the key as the filename so that all\n          // properties of a soul are written to the same file.\n          let end = key.indexOf(enq)\n          if (end === -1) {\n            write.file = key\n          } else {\n            write.file = key.substring(0, end)\n          }\n          // write.limit can be reached after already writing properties of\n          // the current node, so remove it from write.sub before writing to\n          // disk so that it's not duplicated across files.\n          write.sub(write.file, null)\n          write.count = 0\n          radisk.write(name, write.sub, write.next)\n          return true\n        }\n\n        write.sub(key, value)\n      },\n      next: err => {\n        if (err) return cb(err)\n\n        write.sub = Radix()\n        if (!Radix.map(rad, write.slice)) {\n          radisk.write(write.file, write.sub, cb)\n        }\n      },\n    }\n    // If Radix.map doesn't return true when called with write.each as a\n    // callback then didn't need to split the data. The accumulated write.text\n    // can then be stored with write.put().\n    if (!Radix.map(rad, write.each, true)) write.put()\n  }\n\n  radisk.read = (key, cb) => {\n    if (cache) {\n      let value = cache(key)\n      if (typeof value !== \"undefined\") return cb(u, value)\n    }\n    // Only the soul of the key is compared to filenames (see radisk.write).\n    let soul = key\n    let end = key.indexOf(enq)\n    if (end !== -1) {\n      soul = key.substring(0, end)\n    }\n\n    const read = {\n      lex: file => {\n        // store.list should call lex without a file last, which means all file\n        // names were compared to soul, so the current read.file is ok to use.\n        if (!file) {\n          if (!read.file) {\n            cb(\"no file found\", u)\n            return\n          }\n\n          radisk.parse(read.file, read.it)\n          return\n        }\n\n        // Want the filename closest to soul.\n        if (file > soul || file < read.file) return\n\n        read.file = file\n      },\n      it: (err, disk) => {\n        if (err) opt.log(err)\n        if (disk) {\n          cache = disk\n          read.value = disk(key)\n        }\n        cb(err, read.value)\n      },\n    }\n    opt.store.list(read.lex)\n  }\n\n  // Let us start by assuming we are the only process that is\n  // changing the directory or bucket. Not because we do not want\n  // to be multi-process/machine, but because we want to experiment\n  // with how much performance and scale we can get out of only one.\n  // Then we can work on the harder problem of being multi-process.\n  radisk.parse = (file, cb) => {\n    const parse = {\n      disk: Radix(),\n      read: (err, data) => {\n        if (err) return cb(err)\n\n        if (!data) return cb(u, parse.disk)\n\n        let pre = []\n        // Work though data by splitting into 3 values. The first value says\n        // if the second value is one of: the radix level for a key, the key\n        // iteself, or a value. The third is the rest of the data to work with.\n        let tmp = parse.split(data)\n        while (tmp) {\n          let key\n          let value\n          let i = tmp[1]\n          tmp = parse.split(tmp[2]) || \"\"\n          if (tmp[0] === \"#\") {\n            key = tmp[1]\n            pre = pre.slice(0, i)\n            if (i <= pre.length) pre.push(key)\n          }\n          tmp = parse.split(tmp[2]) || \"\"\n          if (tmp[0] === \"\\n\") continue\n\n          if (tmp[0] === \"=\") value = tmp[1]\n          if (typeof key !== \"undefined\" && typeof value !== \"undefined\") {\n            parse.disk(pre.join(\"\"), value)\n          }\n          tmp = parse.split(tmp[2])\n        }\n        cb(u, parse.disk)\n      },\n      split: data => {\n        if (!data) return\n\n        let i = -1\n        let a = \"\"\n        let c = null\n        while ((c = data[++i])) {\n          if (c === unit) break\n\n          a += c\n        }\n        let o = {}\n        if (c) {\n          return [a, Radisk.decode(data.slice(i), o), data.slice(i + o.i)]\n        }\n      },\n    }\n    opt.store.get(file, parse.read)\n  }\n\n  return radisk\n}\n\nRadisk.encode = data => {\n  // A key should be passed in as a string to encode, a value can optionally be\n  // an array of 2 items to include the value's state, as is done by store.js.\n  let state = \"\"\n  if (data instanceof Array && data.length === 2) {\n    state = etx + data[1]\n    data = data[0]\n  }\n\n  if (typeof data === \"string\") {\n    let i = 0\n    let current = null\n    let text = unit\n    while ((current = data[i++])) {\n      if (current === unit) text += unit\n    }\n    return text + '\"' + data + state + unit\n  }\n\n  const rel = utils.rel.is(data)\n  if (rel) return unit + \"#\" + rel + state + unit\n\n  if (utils.num.is(data)) return unit + \"+\" + (data || 0) + state + unit\n\n  if (data === true) return unit + \"+\" + state + unit\n\n  if (data === false) return unit + \"-\" + state + unit\n\n  if (data === null) return unit + \" \" + state + unit\n}\n\nRadisk.decode = (data, obj) => {\n  var text = \"\"\n  var i = -1\n  var n = 0\n  var current = null\n  var previous = null\n  if (data[0] !== unit) return\n\n  // Find a control character previous to the text we want, skipping\n  // consecutive unit separator characters at the beginning of the data.\n  while ((current = data[++i])) {\n    if (previous) {\n      if (current === unit) {\n        if (--n <= 0) break\n      }\n      text += current\n    } else if (current === unit) {\n      n++\n    } else {\n      previous = current || true\n    }\n  }\n\n  if (obj) obj.i = i + 1\n\n  let [value, state] = text.split(etx)\n  if (!state) {\n    if (previous === '\"') return text\n\n    if (previous === \"#\") return utils.rel.ify(text)\n\n    if (previous === \"+\") {\n      if (text.length === 0) return true\n\n      return parseFloat(text)\n    }\n\n    if (previous === \"-\") return false\n\n    if (previous === \" \") return null\n  } else {\n    state = parseFloat(state)\n    // If state was found then return an array.\n    if (previous === '\"') return [value, state]\n\n    if (previous === \"#\") return [utils.rel.ify(value), state]\n\n    if (previous === \"+\") {\n      if (value.length === 0) return [true, state]\n\n      return [parseFloat(value), state]\n    }\n\n    if (previous === \"-\") return [false, state]\n\n    if (previous === \" \") return [null, state]\n  }\n}\n\nmodule.exports = Radisk\n","const utils = require(\"./utils\")\n\n// ASCII character for group separator.\nconst group = String.fromCharCode(29)\n// ASCII character for record separator.\nconst record = String.fromCharCode(30)\n\nconst Radix = () => {\n  const radix = (keys, value, tree) => {\n    if (!tree) {\n      if (!radix[group]) radix[group] = {}\n      tree = radix[group]\n    }\n    if (!keys) return tree\n\n    let i = 0\n    let tmp = {}\n    let key = keys[i]\n    const max = keys.length - 1\n    const noValue = typeof value === \"undefined\"\n    // Find a matching value using the shortest string from keys.\n    let found = tree[key]\n    while (!found && i < max) {\n      key += keys[++i]\n      found = tree[key]\n    }\n\n    if (!found) {\n      // If not found from the provided keys try matching with an existing key.\n      const result = utils.obj.map(tree, (hasValue, hasKey) => {\n        let j = 0\n        let matchingKey = \"\"\n        while (hasKey[j] === keys[j]) {\n          matchingKey += hasKey[j++]\n        }\n        if (matchingKey) {\n          if (noValue) {\n            // matchingKey has to be as long as the original keys when reading.\n            if (j <= max) return\n\n            tmp[hasKey.slice(j)] = hasValue\n            return hasValue\n          }\n\n          let replace = {\n            [hasKey.slice(j)]: hasValue,\n            [keys.slice(j)]: {[record]: value},\n          }\n          tree[matchingKey] = {[group]: replace}\n          delete tree[hasKey]\n          return true\n        }\n      })\n      if (!result) {\n        if (noValue) return\n\n        if (!tree[key]) tree[key] = {}\n        tree[key][record] = value\n      } else if (noValue) {\n        return tmp\n      }\n    } else if (i === max) {\n      // If no value use the key provided to return a whole group or record.\n      if (noValue) {\n        // If an individual record isn't found then return the whole group.\n        return typeof found[record] === \"undefined\"\n          ? found[group]\n          : found[record]\n      }\n      // Otherwise create a new record at the provided key for value.\n      found[record] = value\n    } else {\n      // Found at a shorter key, try again.\n      if (!found[group] && !noValue) found[group] = {}\n      return radix(keys.slice(++i), value, found[group])\n    }\n  }\n  return radix\n}\n\nRadix.map = function map(radix, cb, opt, pre) {\n  if (!pre) pre = []\n  var tree = radix[group] || radix\n  var keys = Object.keys(tree).sort()\n  var u\n\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i]\n    let found = tree[key]\n    let tmp = found[record]\n    if (typeof tmp !== \"undefined\") {\n      tmp = cb(tmp, pre.join(\"\") + key, key, pre)\n      if (typeof tmp !== \"undefined\") return tmp\n    } else if (opt) {\n      cb(u, pre.join(\"\"), key, pre)\n    }\n    if (found[group]) {\n      pre.push(key)\n      tmp = map(found[group], cb, opt, pre)\n      if (typeof tmp !== \"undefined\") return tmp\n      pre.pop()\n    }\n  }\n}\n\nmodule.exports = Radix\n","const jsEnv = require(\"browser-or-node\")\nconst Radisk = require(\"./radisk\")\nconst Radix = require(\"./radix\")\nconst utils = require(\"./utils\")\n\n// ASCII character for enquiry.\nconst enq = String.fromCharCode(5)\n// ASCII character for unit separator.\nconst unit = String.fromCharCode(31)\n\nconst fileSystem = dir => {\n  if (jsEnv.isNode) {\n    const fs = require(\"fs\")\n    if (!fs.existsSync(dir)) {\n      fs.mkdirSync(dir)\n    }\n    if (!fs.existsSync(dir + \"/!\")) {\n      fs.writeFileSync(\n        dir + \"/!\",\n        unit + \"+0\" + unit + \"#\" + unit + '\"root' + unit,\n      )\n    }\n\n    return {\n      get: (file, cb) => {\n        fs.readFile(dir + \"/\" + file, (err, data) => {\n          if (err) {\n            if (err.code === \"ENOENT\") {\n              cb()\n              return\n            }\n\n            console.log(\"filesystem error:\", err)\n          }\n          if (data) data = data.toString()\n          cb(err, data)\n        })\n      },\n      put: (file, data, cb) => {\n        var random = Math.random().toString(36).slice(-9)\n        // Don't put tmp files under dir so that they're not listed.\n        var tmp = file + \".\" + random + \".tmp\"\n        fs.writeFile(tmp, data, err => {\n          if (err) {\n            cb(err)\n            return\n          }\n\n          fs.rename(tmp, dir + \"/\" + file, cb)\n        })\n      },\n      list: cb => {\n        fs.readdir(dir, (err, files) => {\n          files.forEach(cb)\n          cb()\n        })\n      },\n    }\n  }\n\n  // TODO: Add indexedDB\n  return {\n    get: (file, cb) => {\n      cb(null, unit + \"+0\" + unit + \"#\" + unit + '\"root' + unit)\n    },\n    put: (file, data, cb) => {\n      cb(null)\n    },\n    list: cb => {\n      cb(\"!\")\n      cb()\n    },\n  }\n}\n\n// Store provides get and put methods that can access radisk.\nconst Store = opt => {\n  if (!utils.obj.is(opt)) opt = {}\n  opt.file = String(opt.file || \"radata\")\n  if (!opt.store) opt.store = fileSystem(opt.file)\n  const radisk = Radisk(opt)\n\n  return {\n    get: (lex, cb) => {\n      if (!lex) {\n        cb(\"lex required\")\n        return\n      }\n\n      var soul = lex[\"#\"]\n      var key = lex[\".\"] || \"\"\n      var node\n      const each = (value, key) => {\n        if (!node) node = {_: {\"#\": soul, \">\": {}}}\n        node[key] = value[0]\n        node._[\">\"][key] = value[1]\n      }\n\n      radisk(soul + enq + key, (err, value) => {\n        let graph\n        if (utils.obj.is(value)) {\n          Radix.map(value, each)\n          if (!node) each(value, key)\n          graph = {[soul]: node}\n        } else if (value) {\n          each(value, key)\n          graph = {[soul]: node}\n        }\n        cb(err, graph)\n      })\n    },\n    put: (graph, cb) => {\n      if (!graph) {\n        cb(\"graph required\")\n        return\n      }\n\n      var count = 0\n      const ack = err => {\n        count--\n        if (ack.err) return\n\n        ack.err = err\n        if (ack.err) {\n          cb(ack.err)\n          return\n        }\n\n        if (count === 0) cb(null)\n      }\n\n      Object.keys(graph).forEach(soul => {\n        var node = graph[soul]\n        Object.keys(node).forEach(key => {\n          if (key === \"_\") return\n\n          count++\n          let value = node[key]\n          let state = node._[\">\"][key]\n          radisk(soul + enq + key, [value, state], ack)\n        })\n      })\n    },\n  }\n}\n\nmodule.exports = Store\n","const num = {\n  is: n =>\n    !(n instanceof Array) &&\n    (n - parseFloat(n) + 1 >= 0 || Infinity === n || -Infinity === n),\n}\n\nconst obj = {\n  is: o => {\n    if (!o) return false\n\n    return (\n      (o instanceof Object && o.constructor === Object) ||\n      Object.prototype.toString.call(o).match(/^\\[object (\\w+)\\]$/)[1] ===\n        \"Object\"\n    )\n  },\n  map: (list, cb, o) => {\n    var keys = Object.keys(list)\n    for (let i = 0; i < keys.length; i++) {\n      let result = cb(list[keys[i]], keys[i], o)\n      if (typeof result !== \"undefined\") return result\n    }\n  },\n  put: (o, key, value) => {\n    if (!o) o = {}\n    o[key] = value\n    return o\n  },\n  del: (o, key) => {\n    if (!o) return\n\n    o[key] = null\n    delete o[key]\n    return o\n  },\n}\n\nconst map_soul = (soul, key, o) => {\n  // If id is already defined AND we're still looping through the object,\n  // then it is considered invalid.\n  if (o.id) {\n    o.id = false\n    return\n  }\n\n  if (key === \"#\" && typeof soul === \"string\") {\n    o.id = soul\n    return\n  }\n\n  // If there exists anything else on the object that isn't the soul,\n  // then it is considered invalid.\n  o.id = false\n}\n\n// Check if an object is a soul relation, ie {'#': 'UUID'}\nconst rel = {\n  is: value => {\n    if (value && value[\"#\"] && !value._ && obj.is(value)) {\n      let o = {}\n      obj.map(value, map_soul, o)\n      if (o.id) return o.id\n    }\n\n    return false\n  },\n  // Convert a soul into a relation and return it.\n  ify: soul => obj.put({}, \"#\", soul),\n}\n\nconst text = {\n  random: length => {\n    var s = \"\"\n    const c = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXZabcdefghijklmnopqrstuvwxyz\"\n    if (!length) length = 24\n    for (let i = 0; i < length; i++) {\n      s += c.charAt(Math.floor(Math.random() * c.length))\n    }\n    return s\n  },\n}\n\nmodule.exports = {num, obj, rel, text}\n","const jsEnv = require(\"browser-or-node\")\nconst Dup = require(\"./dup\")\nconst Get = require(\"./get\")\nconst Ham = require(\"./ham\")\nconst Store = require(\"./store\")\nconst utils = require(\"./utils\")\n\n// ASCII character for enquiry.\nconst enq = String.fromCharCode(5)\n\n// Wire starts a websocket client or server and returns get and put methods\n// for access to the wire spec and storage.\nconst Wire = opt => {\n  if (!utils.obj.is(opt)) opt = {}\n\n  const dup = Dup(opt.maxAge)\n  const store = Store(opt)\n  const graph = {}\n  const queue = {}\n  const listen = {}\n\n  const get = (msg, send) => {\n    const ack = Get(msg.get, graph)\n    if (ack) {\n      send(\n        JSON.stringify({\n          \"#\": dup.track(utils.text.random(9)),\n          \"@\": msg[\"#\"],\n          put: ack,\n        }),\n      )\n    } else {\n      store.get(msg.get, (err, ack) => {\n        send(\n          JSON.stringify({\n            \"#\": dup.track(utils.text.random(9)),\n            \"@\": msg[\"#\"],\n            put: ack,\n            err: err,\n          }),\n        )\n      })\n    }\n  }\n\n  const put = (msg, send) => {\n    // Store updates returned from Ham.mix and defer updates if required.\n    const update = Ham.mix(msg.put, graph, listen)\n    store.put(update.now, err => {\n      send(\n        JSON.stringify({\n          \"#\": dup.track(utils.text.random(9)),\n          \"@\": msg[\"#\"],\n          err: err,\n        }),\n      )\n    })\n    if (update.wait !== 0) {\n      setTimeout(() => put({put: update.defer}, send), update.wait)\n    }\n  }\n\n  const api = send => {\n    return {\n      get: (lex, cb, opt) => {\n        if (!cb) return\n\n        if (!utils.obj.is(opt)) opt = {}\n        const ack = Get(lex, graph)\n        if (ack) {\n          cb({put: ack})\n          return\n        }\n\n        store.get(lex, (err, ack) => {\n          if (ack) {\n            cb({put: ack, err: err})\n            return\n          }\n\n          if (err) console.log(err)\n\n          const track = utils.text.random(9)\n          queue[track] = cb\n          send(\n            JSON.stringify({\n              \"#\": dup.track(track),\n              get: lex,\n            }),\n          )\n          // Respond to callback with null if no response.\n          setTimeout(() => {\n            const cb = queue[track]\n            if (cb) {\n              const id = lex[\"#\"]\n              const ack = {[id]: null}\n              if (lex[\".\"]) ack[id] = {[lex[\".\"]]: null}\n              cb({put: ack})\n              delete queue[track]\n            }\n          }, opt.wait || 100)\n        })\n      },\n      put: (data, cb) => {\n        // Deferred updates are only stored using wire spec, they're ignored\n        // here using the api. This is ok because correct timestamps should be\n        // used whereas wire spec needs to handle clock skew.\n        const update = Ham.mix(data, graph, listen)\n        store.put(update.now, cb)\n        // Also put data on the wire spec.\n        // TODO: Note that this means all clients now receive all updates, so\n        // need to filter what should be stored, both in graph and on disk.\n        send(\n          JSON.stringify({\n            \"#\": dup.track(utils.text.random(9)),\n            put: data,\n          }),\n        )\n      },\n      on: (lex, cb) => {\n        if (!cb) return\n\n        let id = lex[\"#\"]\n        if (!id) return\n\n        if (lex[\".\"]) id += enq + lex[\".\"]\n        if (listen[id]) {\n          if (!listen[id].includes(cb)) listen[id].push(cb)\n        } else {\n          listen[id] = [cb]\n        }\n      },\n      off: (lex, cb) => {\n        let id = lex[\"#\"]\n        if (!id) return\n\n        if (lex[\".\"]) id += enq + lex[\".\"]\n        if (!listen[id]) return\n\n        if (cb) {\n          if (listen[id].includes(cb)) {\n            listen[id].splice(listen[id].indexOf(cb), 1)\n          }\n        } else {\n          // Remove all callbacks when none provided.\n          delete listen[id]\n        }\n      },\n    }\n  }\n\n  if (jsEnv.isNode) {\n    const WebSocket = require(\"ws\")\n    let wss = opt.wss\n    // Node's websocket server provides clients as an array, whereas\n    // mock-sockets provides clients as a function that returns an array.\n    let clients = () => wss.clients()\n    if (!wss) {\n      wss = new WebSocket.Server({port: 8080})\n      clients = () => wss.clients\n    }\n\n    const send = (data, isBinary) => {\n      clients().forEach(client => {\n        if (client.readyState === WebSocket.OPEN) {\n          client.send(data, {binary: isBinary})\n        }\n      })\n    }\n    wss.on(\"connection\", ws => {\n      ws.on(\"error\", console.error)\n\n      ws.on(\"message\", (data, isBinary) => {\n        const msg = JSON.parse(data)\n        if (dup.check(msg[\"#\"])) return\n\n        dup.track(msg[\"#\"])\n        if (msg.get) get(msg, send)\n        if (msg.put) put(msg, send)\n        send(data, isBinary)\n\n        const id = msg[\"@\"]\n        const cb = queue[id]\n        if (cb) {\n          delete msg[\"#\"]\n          delete msg[\"@\"]\n          cb(msg)\n\n          delete queue[id]\n        }\n      })\n    })\n    return api(send)\n  }\n\n  let ws = new WebSocket(\"ws://localhost:8080\")\n  const send = data => {\n    if (!ws || ws.readyState !== WebSocket.OPEN) {\n      console.log(\"websocket not available\")\n      return\n    }\n\n    ws.send(data)\n  }\n  const start = () => {\n    if (!ws) ws = new WebSocket(\"ws://localhost:8080\")\n    ws.onclose = c => {\n      ws = null\n      setTimeout(start, Math.floor(Math.random() * 5000))\n    }\n    ws.onerror = e => {\n      console.error(e)\n    }\n    ws.onmessage = m => {\n      const msg = JSON.parse(m.data)\n      if (dup.check(msg[\"#\"])) return\n\n      dup.track(msg[\"#\"])\n      if (msg.get) get(msg, send)\n      if (msg.put) put(msg, send)\n      send(m.data)\n\n      const id = msg[\"@\"]\n      const cb = queue[id]\n      if (cb) {\n        delete msg[\"#\"]\n        delete msg[\"@\"]\n        cb(msg)\n\n        delete queue[id]\n      }\n    }\n  }\n\n  start()\n  return api(send)\n}\n\nmodule.exports = Wire\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(299);\n"],"names":["mod","__defProp","Object","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__hasOwnProp","prototype","hasOwnProperty","src_exports","target","all","name","get","enumerable","__export","isBrowser","isBun","isDeno","isJsDom","isNode","isWebWorker","module","exports","to","from","except","desc","key","call","__copyProps","value","window","document","process","versions","node","self","constructor","navigator","userAgent","includes","Deno","version","deno","bun","Error","maxAge","dup","store","id","track","Date","now","expiry","setTimeout","keys","forEach","lex","graph","soul","_","enq","String","fromCharCode","Ham","state","currentState","currentValue","historical","incoming","JSON","stringify","current","mix","change","listen","machine","defer","wait","updated","skew","cb","utils","Wire","opt","wire","map","Map","allctx","ok","data","rel","is","num","g","entries","api","ctxid","ack","obj","put","async","msg","err","console","log","Promise","res","_ctxid","text","random","set","chain","item","then","done","ctx","on","delete","resolve","request","off","found","i","length","ify","push","result","check","update","Radix","etx","unit","Radisk","u","cache","batch","write","size","list","radisk","thrash","at","read","acks","ed","clearTimeout","timeout","ing","more","save","rad","find","tree","start","file","end","parse","disk","next","count","each","k","pre","enc","encode","limit","Math","ceil","sub","slice","indexOf","substring","it","tmp","split","join","a","c","o","decode","Array","n","previous","parseFloat","group","record","radix","max","noValue","hasValue","hasKey","j","matchingKey","replace","sort","pop","jsEnv","dir","fs","existsSync","mkdirSync","writeFileSync","readFile","code","toString","writeFile","rename","readdir","files","fileSystem","Infinity","match","del","map_soul","s","charAt","floor","Dup","Get","Store","queue","send","splice","WebSocket","wss","clients","Server","port","isBinary","client","readyState","OPEN","binary","ws","error","onclose","onerror","e","onmessage","m","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__"],"sourceRoot":""}