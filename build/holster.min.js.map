{"version":3,"file":"holster.min.js","mappings":"qBAAA,IAgBoBA,EAhBhBC,EAAYC,OAAOC,eACnBC,EAAmBF,OAAOG,yBAC1BC,EAAoBJ,OAAOK,oBAC3BC,EAAeN,OAAOO,UAAUC,eAgBhCC,EAAc,CAAC,EAfJ,EAACC,EAAQC,KACtB,IAAK,IAAIC,KAAQD,EACfZ,EAAUW,EAAQE,EAAM,CAAEC,IAAKF,EAAIC,GAAOE,YAAY,GAAO,EAcjEC,CAASN,EAAa,CACpBO,UAAW,IAAMA,EACjBC,MAAO,IAAMA,EACbC,OAAQ,IAAMA,EACdC,QAAS,IAAMA,EACfC,OAAQ,IAAMA,EACdC,YAAa,IAAMA,IAErBC,EAAOC,SAZazB,EAYUW,EApBZ,EAACe,EAAIC,EAAMC,EAAQC,KACnC,GAAIF,GAAwB,iBAATA,GAAqC,mBAATA,EAC7C,IAAK,IAAIG,KAAOxB,EAAkBqB,GAC3BnB,EAAauB,KAAKL,EAAII,IAKLE,YALaF,GACjC7B,EAAUyB,EAAII,EAAK,CAAEf,IAAK,IAAMY,EAAKG,GAAMd,aAAca,EAAOzB,EAAiBuB,EAAMG,KAASD,EAAKb,aAE3G,OAAOU,CAAE,EAEiBM,CAAY/B,EAAU,CAAC,EAAG,aAAc,CAAEgC,OAAO,IAASjC,IAatF,IAAIkB,EAA8B,oBAAXgB,aAAqD,IAApBA,OAAOC,SAC3Db,EAEiB,oBAAZc,SACa,MAApBA,QAAQC,UACiB,MAAzBD,QAAQC,SAASC,KAEff,EAA8B,iBAATgB,MAAqBA,KAAKC,aAAyC,+BAA1BD,KAAKC,YAAY1B,KAC/EO,EAA4B,oBAAXa,QAA0C,WAAhBA,OAAOpB,MAA0C,oBAAd2B,WAA6B,cAAeA,WAA4C,iBAAxBA,UAAUC,YAA2BD,UAAUC,UAAUC,SAAS,YAAcF,UAAUC,UAAUC,SAAS,UAC3PvB,EAEc,oBAATwB,WACiB,IAAjBA,KAAKC,cACiB,IAAtBD,KAAKC,QAAQC,KAElB3B,EAA2B,oBAAZiB,SAA+C,MAApBA,QAAQC,UAA4C,MAAxBD,QAAQC,SAASU,G,uBC1C3FvB,EAAOC,QAAU,WACf,MAAM,IAAIuB,MACR,wFAGJ,C,SCPA,MAAMC,EAAM,KACV,MACMC,EAAM,CAACC,MAAO,CAAC,EACrBD,MAAYE,KAAOF,EAAIC,MAAMC,IAAMF,EAAIG,MAAMD,GAC7CF,MAAYE,IAEVF,EAAIC,MAAMC,GAAME,KAAKC,MAChBL,EAAIM,SACPN,EAAIM,OAASC,YAAW,KACtB,MAAMF,EAAMD,KAAKC,MACjBrD,OAAOwD,KAAKR,EAAIC,OAAOQ,SAAQP,IACzBG,EAAML,EAAIC,MAAMC,GAVb,YAUkCF,EAAIC,MAAMC,EAAE,IAEvDF,EAAIM,OAAS,OAZJ,MAeNJ,IAET,OAAOF,GAGTD,EAAIW,OAAS,IACJC,KAAKD,SAASE,SAAS,IAAIC,OAAO,GAG3CvC,EAAOC,QAAUwB,C,UCPjBzB,EAAOC,QAlBK,CAACuC,EAAKC,KAChB,MAAMC,EAAOF,EAAI,KACXlC,EAAMkC,EAAI,KAChB,IAAI1B,EAAO2B,EAAMC,GAKjB,IAAK5B,IAASR,EAAK,OAEnB,IAAIG,EAAQK,EAAKR,GACjB,OAAKG,IAELK,EAAO,CAAC6B,EAAG7B,EAAK6B,EAAG,CAACrC,GAAMG,IACrBkC,EAAE,KAAO,CAAC,CAACrC,GAAMQ,EAAK6B,EAAE,KAAKrC,IAC3B,CAAC,CAACoC,GAAO5B,SAJhB,CAIoB,C,UCbtB,MAAM8B,EAAM,CAACC,EAAOC,EAAcrC,EAAOsC,IACnCF,EAAQC,EACH,CAACE,YAAY,GAGlBH,EAAQC,EACH,CAACG,UAAU,IAIpBxC,EAAQyC,KAAKC,UAAU1C,IAAU,OACjCsC,EAAeG,KAAKC,UAAUJ,IAAiB,IAGtC,CAACF,OAAO,GAIbpC,EAAQsC,EACH,CAACK,SAAS,GAIZ,CAACH,UAAU,GAGpBL,EAAIS,IAAM,CAACC,EAAQb,KACjB,IAAIc,EAAUzB,KAAKC,MACfyB,EAAS,CAAC,EACVC,EAAQ,CAAC,EACb,IAAIC,EAAO,EAqCX,OAnCAhF,OAAOwD,KAAKoB,GAAQnB,SAAQO,IAC1B,MAAM5B,EAAOwC,EAAOZ,GACpBhE,OAAOwD,KAAKpB,GAAMqB,SAAQ7B,IACxB,GAAY,MAARA,EAAa,OAEjB,MAAMG,EAAQK,EAAKR,GACbuC,EAAQ/B,EAAK6B,EAAE,KAAKrC,GACpByC,GAAgBN,EAAMC,IAAS,CAAC,GAAGpC,GACnCwC,GAAgBL,EAAMC,IAAS,CAACC,EAAG,CAAC,IAAK,CAAC,KAAKA,EAAE,KAAKrC,IAAQ,EAG9DqD,EAAOd,EAAQU,EACrB,GAAII,EAAO,EAAG,CAEZ,GAAIA,EAAO,MAAU,QAGR,IAATD,GAAcC,EAAOD,KAAMA,EAAOC,GACjCF,EAAMf,KAAOe,EAAMf,GAAQ,CAACC,EAAG,CAAC,IAAKD,EAAM,IAAK,CAAC,KACtDe,EAAMf,GAAMpC,GAAOG,EACnBgD,EAAMf,GAAMC,EAAE,KAAKrC,GAAOuC,CAC5B,MACiBD,EAAIC,EAAOC,EAAcrC,EAAOsC,GACpCE,WACJO,EAAOd,KAAOc,EAAOd,GAAQ,CAACC,EAAG,CAAC,IAAKD,EAAM,IAAK,CAAC,KAInDD,EAAMC,KAAOD,EAAMC,GAAQ,CAACC,EAAG,CAAC,IAAKD,EAAM,IAAK,CAAC,KACtDD,EAAMC,GAAMpC,GAAOkD,EAAOd,GAAMpC,GAAOG,EACvCgC,EAAMC,GAAMC,EAAE,KAAKrC,GAAOkD,EAAOd,GAAMC,EAAE,KAAKrC,GAAOuC,EAEzD,GACD,IAEI,CAACd,IAAKyB,EAAQC,MAAOA,EAAOC,KAAMA,EAAI,EAG/C1D,EAAOC,QAAU2C,C,gBCxEjB,MAAMgB,EAAQ,EAAQ,KAChBnC,EAAM,EAAQ,IACdoC,EAAM,EAAQ,KACdjB,EAAM,EAAQ,KACdkB,EAAQ,EAAQ,KAiKtB9D,EAAOC,QA/JS8D,IACd,MAAMrC,EAAMD,IACNE,EAAQmC,EAAMC,GACpB,IAAItB,EAAQ,CAAC,EACTuB,EAAQ,CAAC,EAEb,MAAMzE,EAAM,CAAC0E,EAAKC,KAChB,MAAMC,EAAMN,EAAII,EAAI1E,IAAKkD,GACrB0B,EACFD,EACEhB,KAAKC,UAAU,CACb,IAAKzB,EAAIG,MAAMJ,EAAIW,UACnB,IAAK6B,EAAI,KACTG,IAAKD,KAITxC,EAAMpC,IAAI0E,EAAI1E,KAAK,CAAC8E,EAAKF,KACvBD,EACEhB,KAAKC,UAAU,CACb,IAAKzB,EAAIG,MAAMJ,EAAIW,UACnB,IAAK6B,EAAI,KACTG,IAAKD,EACLE,IAAKA,IAET,GAEJ,EAGID,EAAM,CAACH,EAAKC,KAEhB,MAAMV,EAASZ,EAAIS,IAAIY,EAAIG,IAAK3B,GAChCd,EAAMyC,IAAIZ,EAAOzB,KAAK,CAACsC,EAAKC,KAC1BJ,EACEhB,KAAKC,UAAU,CACb,IAAKzB,EAAIG,MAAMJ,EAAIW,UACnB,IAAK6B,EAAI,KACTI,IAAKA,EACLC,GAAIA,IAER,IAEkB,IAAhBd,EAAOE,MACTzB,YAAW,IAAMmC,EAAIZ,EAAOC,MAAOS,IAAOV,EAAOE,KACnD,EAGIa,EAAML,IACH,CACL3E,IAAK,CAACiD,EAAKgC,KACT,MAAML,EAAMN,EAAIrB,EAAKC,GACjB0B,EACFK,EAAG,KAAML,GAIXxC,EAAMpC,IAAIiD,GAAK,CAAC6B,EAAKF,KACnB,GAAIA,EAEF,YADAK,EAAG,KAAML,GAIX,MAAMtC,EAAQJ,EAAIW,SAClB4B,EAAMnC,GAAS2C,EACfN,EACEhB,KAAKC,UAAU,CACb,IAAKzB,EAAIG,MAAMA,GACftC,IAAKiD,IAET,GACD,EAEH4B,IAAK,CAACK,EAAMD,KAIV,MAAMhB,EAASZ,EAAIS,IAAIoB,EAAMhC,GAC7Bd,EAAMyC,IAAIZ,EAAOzB,IAAKyC,GAItBN,EACEhB,KAAKC,UAAU,CACb,IAAKzB,EAAIG,MAAMJ,EAAIW,UACnBgC,IAAKK,IAET,IAKN,GAAIb,EAAM9D,OAAQ,CAChB,MAAM4E,EAAY,EAAQ,KACpBC,EAAM,IAAID,EAAUE,OAAO,CAACC,KAAM,OAClCX,EAAO,CAACO,EAAMK,KAClBH,EAAII,QAAQ5C,SAAQ6C,IACdA,EAAOC,aAAeP,EAAUQ,MAClCF,EAAOd,KAAKO,EAAM,CAACU,OAAQL,GAC7B,GACD,EAmBH,OAjBAH,EAAIS,GAAG,cAAcC,IACnBA,EAAGD,GAAG,QAASE,QAAQC,OAEvBF,EAAGD,GAAG,WAAW,CAACX,EAAMK,KACtB,MAAMb,EAAMf,KAAKsC,MAAMf,GACnB/C,EAAI+D,MAAMxB,EAAI,QAElBvC,EAAIG,MAAMoC,EAAI,MACVA,EAAI1E,KAAKA,EAAI0E,EAAKC,GAClBD,EAAIG,KAAKA,EAAIH,EAAKC,GACtBA,EAAKO,EAAMK,IACNN,GAAKR,EAAMC,EAAI,SAClBO,GAAG,KAAMP,UACFD,EAAMC,EAAI,OACnB,GACD,IAEIM,EAAIL,EACb,CAEA,IAAImB,EAAK,IAAIX,UAAU,uBACvB,MAAMR,EAAOO,IACNY,GAAMA,EAAGJ,aAAeP,UAAUQ,KAKvCG,EAAGnB,KAAKO,GAJNa,QAAQI,IAAI,0BAIF,EAERC,EAAQ,KACPN,IAAIA,EAAK,IAAIX,UAAU,wBAC5BW,EAAGO,QAAUC,IACXR,EAAK,KACLpD,WAAW0D,EAAOtD,KAAKyD,MAAsB,IAAhBzD,KAAKD,UAAgB,EAEpDiD,EAAGU,QAAUC,IACXV,QAAQC,MAAMS,EAAC,EAEjBX,EAAGY,UAAYC,IACb,MAAMjC,EAAMf,KAAKsC,MAAMU,EAAEzB,MACrB/C,EAAI+D,MAAMxB,EAAI,QAElBvC,EAAIG,MAAMoC,EAAI,MACVA,EAAI1E,KAAKA,EAAI0E,EAAKC,GAClBD,EAAIG,KAAKA,EAAIH,EAAKC,IACjBM,GAAKR,EAAMC,EAAI,SAClBO,GAAG,KAAMP,UACFD,EAAMC,EAAI,OAEnBC,EAAKgC,EAAEzB,MAAI,CACb,EAIF,OADAkB,IACOpB,EAAIL,EAAI,C,gBClKjB,MAAMiC,EAAQ,EAAQ,IAChBC,EAAQ,EAAQ,KAGhBC,EAAOC,OAAOC,aAAa,IAE3BC,EAASzC,IACb,IAAI0C,EACAC,EAAQ,KAQZ,GANK3C,IAAKA,EAAM,CAAC,GACZA,EAAI2B,MAAK3B,EAAI2B,IAAMJ,QAAQI,KAC3B3B,EAAI4C,QAAO5C,EAAI4C,MAAQ,KACvB5C,EAAIL,OAAMK,EAAIL,KAAO,GACrBK,EAAI6C,OAAM7C,EAAI6C,KAAO,SACrB7C,EAAI8C,OAAM9C,EAAI8C,KAAO,MACrB9C,EAAIpC,MAIP,YAHAoC,EAAI2B,IACF,sEAIJ,IAAK3B,EAAIpC,MAAMpC,IAEb,YADAwE,EAAI2B,IAAI,wDAGV,IAAK3B,EAAIpC,MAAMyC,IAEb,YADAL,EAAI2B,IAAI,8DAGV,IAAK3B,EAAIpC,MAAMmF,KAEb,YADA/C,EAAI2B,IAAI,+DAYV,MAAMqB,EAAS,CAACzG,EAAKG,EAAO+D,KAC1BlE,EAAM,GAAKA,EAIU,mBAAVG,GACT+D,EAAK/D,OAEgB,KADrBA,EAAQsG,EAAOJ,MAAMrG,KAKjByG,EAAOC,OAAOC,SAEK,KADrBxG,EAAQsG,EAAOC,OAAOC,GAAG3G,IAJlBkE,EAAGiC,EAAGhG,GAURsG,EAAOG,KAAK5G,EAAKkE,KAI1BuC,EAAOJ,MAAMrG,EAAKG,GACd+D,GACFuC,EAAOJ,MAAMQ,KAAKC,KAAK5C,KAGnBuC,EAAOJ,MAAMU,IAAMtD,EAAI4C,MACpBI,EAAOC,UAIhBM,aAAaP,EAAOJ,MAAMY,cAC1BR,EAAOJ,MAAMY,QAAUtF,WAAW8E,EAAOC,OAAQjD,EAAIL,UAoQvD,OAjQAqD,EAAOJ,MAAQR,IACfY,EAAOJ,MAAMQ,KAAO,GACpBJ,EAAOJ,MAAMU,GAAK,EAElBN,EAAOC,OAAS,KACd,GAAID,EAAOC,OAAOQ,IAChB,OAAQT,EAAOC,OAAOS,MAAO,EAG/BH,aAAaP,EAAOJ,MAAMY,SAC1BR,EAAOC,OAAOS,MAAO,EACrBV,EAAOC,OAAOQ,KAAM,EACpB,IAAIb,EAASI,EAAOC,OAAOC,GAAKF,EAAOJ,MACvCI,EAAOJ,MAAQ,KACfI,EAAOJ,MAAQR,IACfY,EAAOJ,MAAMQ,KAAO,GACpBJ,EAAOJ,MAAMU,GAAK,EAClB,IAAIK,EAAI,EACRX,EAAOY,KAAKhB,GAAO,CAACtC,EAAKC,OAIjBoD,EAAI,IAENrD,GAAKN,EAAI2B,IAAIrB,GACjBsC,EAAMQ,KAAKhF,SAAQqC,GAAMA,EAAGH,EAAKC,KACjCyC,EAAOC,OAAOC,GAAK,KACnBF,EAAOC,OAAOQ,KAAM,EAChBT,EAAOC,OAAOS,MAAMV,EAAOC,SAAO,GACvC,EAYHD,EAAOY,KAAO,CAACC,EAAKpD,KAClB,MAAMmD,EAAO,CACXE,KAAM,CAACC,EAAMxH,KAEX,KAAIA,EAAMqH,EAAKhC,OAIf,OAFAgC,EAAKhC,MAAQrF,EACbyD,EAAIpC,MAAMmF,KAAKa,EAAKnF,MACb,GAETA,IAAKuF,IACH,IAAKA,GAAQA,EAAOJ,EAAKhC,MAGvB,OAFAgC,EAAKK,IAAMD,EACXJ,EAAKtE,IAAIsE,EAAKI,MAAQhE,EAAI8C,KAAMc,EAAKhC,MAAOgC,EAAKK,MAC1C,EAGTL,EAAKI,KAAOA,GAEd1E,IAAK,CAAC0E,EAAMpC,EAAOqC,KACjBL,EAAKhC,MAAQgC,EAAKK,IAAML,EAAKI,KAAOtB,EACpCM,EAAOvB,MAAMuC,GAAM,CAAC1D,EAAK4D,KACvB,GAAI5D,EAAK,OAAOG,EAAGH,GAEnB8B,EAAM+B,IAAIN,GAAK,CAACnH,EAAOH,KACrB,KAAIA,EAAMqF,GAEV,OAAIqC,GAAOA,EAAM1H,GACfqH,EAAKhC,MAAQrF,EACNqH,EAAKhC,YAGdsC,EAAK3H,EAAKG,EAAK,IAEjBsG,EAAOoB,MAAMJ,EAAME,EAAMN,EAAKS,KAAI,GACnC,EAEHA,KAAM,CAAC/D,EAAKC,IACND,EAAYG,EAAGH,GAEfsD,EAAKhC,MAAcQ,EAAM+B,IAAIN,EAAKD,EAAKE,WAE3CrD,EAAGH,EAAKC,IAGZ6B,EAAM+B,IAAIN,EAAKD,EAAKE,KAAI,EAS1Bd,EAAOoB,MAAQ,CAACJ,EAAMH,EAAKpD,KAEzBkC,EAAQ,KACR,MAAMyB,EAAQ,CACZE,KAAM,GACNC,MAAO,EACPP,KAAMA,EACNQ,KAAM,CAAC9H,EAAOH,EAAKkI,EAAGC,KACpBN,EAAMG,QACN,IAAII,EACFlC,EAAOmC,OAAOF,EAAIG,QAClB,IACApC,EAAOmC,OAAOH,SACI,IAAV/H,EAAwB,GAAK,IAAM+F,EAAOmC,OAAOlI,IACzD,KAEF,GAAI0H,EAAMG,MAAQ,GAAKH,EAAME,KAAKO,OAASF,EAAIE,OAAS7E,EAAI6C,KAO1D,OANAuB,EAAME,KAAO,GAEbF,EAAMU,MAAQxG,KAAKyG,KAAKX,EAAMG,MAAQ,GACtCH,EAAMG,MAAQ,EACdH,EAAMY,IAAM5C,IACZA,EAAM+B,IAAIN,EAAKO,EAAM5F,QACd,EAGT4F,EAAME,MAAQK,GAEhBtE,IAAK,KACHL,EAAIpC,MAAMyC,IAAI2D,EAAMI,EAAME,KAAM7D,EAAE,EAEpCjC,MAAO,CAAC9B,EAAOH,KACb,KAAIA,EAAM6H,EAAMJ,MAAhB,CAEA,KAAMI,EAAMG,MAAQH,EAAMU,MAAO,CAC/B,IAAIvJ,EAAO6I,EAAMJ,KAGjB,IAAIC,EAAM1H,EAAI0I,QAAQ,KAQtB,OANEb,EAAMJ,MADK,IAATC,EACW1H,EAEAA,EAAI2I,UAAU,EAAGjB,GAEhCG,EAAMG,MAAQ,EACdvB,EAAOoB,MAAM7I,EAAM6I,EAAMY,IAAKZ,EAAMC,OAC7B,CACT,CAEAD,EAAMY,IAAIzI,EAAKG,EAjBO,CAiBF,EAEtB2H,KAAM/D,IACJ,GAAIA,EAAK,OAAOG,EAAGH,GAEnB8D,EAAMY,IAAM5C,IACPA,EAAM+B,IAAIN,EAAKO,EAAM5F,QACxBwE,EAAOoB,MAAMA,EAAMJ,KAAMI,EAAMY,IAAKvE,EACtC,GAMC2B,EAAM+B,IAAIN,EAAKO,EAAMI,MAAM,IAAOJ,EAAM/D,KAAI,EAGnD2C,EAAOG,KAAO,CAAC5G,EAAKkE,KAClB,GAAIkC,EAAO,CACT,IAAIjG,EAAQiG,EAAMpG,GAClB,QAAqB,IAAVG,EAAuB,OAAO+D,EAAGiC,EAAGhG,EACjD,CAEA,MAAMyG,EAAO,CACX1E,IAAKuF,IAIH,IAAKA,GAAQA,EAAOzH,EAAK,CACvB,IAAK4G,EAAKa,KAER,YADAvD,EAAG,gBAAiBiC,GAItB,GAAIS,EAAKM,IAAK,OAId,OAFAN,EAAKM,KAAM,OACXT,EAAOvB,MAAM0B,EAAKa,KAAMb,EAAKgC,GAE/B,CAEAhC,EAAKa,KAAOA,GAEdmB,GAAI,CAAC7E,EAAK4D,KACJ5D,GAAKN,EAAI2B,IAAIrB,GACb4D,IACFvB,EAAQuB,EACRf,EAAKzG,MAAQwH,EAAK3H,IAEpBkE,EAAGH,EAAK6C,EAAKzG,MAAK,GAGtBsD,EAAIpC,MAAMmF,KAAKI,EAAK1E,IAAG,EAUzBuE,EAAOvB,MAAQ,CAACuC,EAAMvD,KACpB,MAAMgB,EAAQ,CACZyC,KAAM9B,IACNe,KAAM,CAAC7C,EAAKI,KACV,GAAIJ,EAAK,OAAOG,EAAGH,GAEnB,IAAKI,EAAM,OAAOD,EAAGiC,EAAGjB,EAAMyC,MAE9B,IAAIQ,EAAM,GACNU,EAAM3D,EAAM4D,MAAM3E,GACtB,KAAO0E,GAAK,CACV,IAAI7I,EACAG,EACAiH,EAAIyB,EAAI,GACZA,EAAM3D,EAAM4D,MAAMD,EAAI,KAAO,GACd,MAAXA,EAAI,KACN7I,EAAM6I,EAAI,GACVV,EAAMA,EAAIlG,MAAM,EAAGmF,GACfA,GAAKe,EAAIG,QAAQH,EAAIrB,KAAK9G,IAEhC6I,EAAM3D,EAAM4D,MAAMD,EAAI,KAAO,GACd,OAAXA,EAAI,KAEO,MAAXA,EAAI,KAAY1I,EAAQ0I,EAAI,SACb,IAAR7I,QAAwC,IAAVG,GACvC+E,EAAMyC,KAAKQ,EAAIY,KAAK,IAAK5I,GAE3B0I,EAAM3D,EAAM4D,MAAMD,EAAI,IACxB,CACA3E,EAAGiC,EAAGjB,EAAMyC,KAAI,EAElBmB,MAAO3E,IACL,IAAKA,EAAM,OAEX,IAAIiD,GAAK,EACL4B,EAAI,GACJzD,EAAI,KACR,MAAQA,EAAIpB,IAAOiD,KACb7B,IAAMQ,GAEViD,GAAKzD,EAEP,IAAI0D,EAAI,CAAC,EACT,OAAI1D,EACK,CAACyD,EAAG9C,EAAOgD,OAAO/E,EAAKlC,MAAMmF,GAAI6B,GAAI9E,EAAKlC,MAAMmF,EAAI6B,EAAE7B,SAD/D,CAEA,GAGJ3D,EAAIpC,MAAMpC,IAAIwI,EAAMvC,EAAM0B,KAAI,EAGzBH,GAGTP,EAAOmC,OAASlE,IACd,GAAmB,iBAARA,EAAkB,CAC3B,IAAIiD,EAAI,EACJtE,EAAU,KACViF,EAAOhC,EACX,KAAQjD,EAAUqB,EAAKiD,MACjBtE,IAAYiD,IAAMgC,GAAQhC,GAEhC,OAAOgC,EAAO,IAAM5D,EAAO4B,CAC7B,CAEA,IAAI8C,EAAM,KACV,OAAI1E,GAAQA,EAAK,OAAS0E,EAAM/C,EAAMqD,IAAIC,GAAGjF,IACpC4B,EAAO,IAAM8C,EAAM9C,EAExBD,EAAMuD,IAAID,GAAGjF,GAAc4B,EAAO,KAAO5B,GAAQ,GAAK4B,EAE7C,OAAT5B,EAAsB4B,EAAO,IAAMA,GAE1B,IAAT5B,EAAsB4B,EAAO,IAAMA,GAE1B,IAAT5B,EAAuB4B,EAAO,IAAMA,OAAxC,CAAwCA,EAG1CG,EAAOgD,OAAS,CAAC/E,EAAMmF,KACrB,IAAIvB,EAAO,GACPX,GAAK,EACLmC,EAAI,EACJzG,EAAU,KACV0G,EAAW,KACf,GAAIrF,EAAK,KAAO4B,EAAhB,CAIA,KAAQjD,EAAUqB,IAAOiD,IACvB,GAAIoC,EAAU,CACZ,GAAI1G,IAAYiD,KACRwD,GAAK,EAAG,MAEhBxB,GAAQjF,CACV,MAAWA,IAAYiD,EACrBwD,IAEAC,EAAW1G,IAAW,EAM1B,OAFIwG,IAAKA,EAAIlC,EAAIA,EAAI,GAEJ,MAAboC,EAAyBzB,EAEZ,MAAbyB,EAAyB1D,EAAMqD,IAAIM,IAAI1B,GAE1B,MAAbyB,EACkB,IAAhBzB,EAAKO,QAEFoB,WAAW3B,GAGH,MAAbyB,EAAyB,KAEZ,MAAbA,QAAJ,CA/BsB,CA+BO,EAG/B9J,EAAOC,QAAUuG,C,eCpZjB,MAAMJ,EAAQ,EAAQ,KAGhB6D,EAAQ3D,OAAOC,aAAa,IAE5B2D,EAAS5D,OAAOC,aAAa,IAE7BJ,EAAQ,KACZ,MAAMgE,EAAQ,CAACjI,EAAMzB,EAAOqH,KAK1B,GAJKA,IACEqC,EAAMF,KAAQE,EAAMF,GAAS,CAAC,GACnCnC,EAAOqC,EAAMF,KAEV/H,EAAM,OAAO4F,EAElB,IAAIJ,EAAI,EACJyB,EAAM,CAAC,EACP7I,EAAM4B,EAAKwF,GACf,MAAM0C,EAAMlI,EAAK0G,OAAS,EACpByB,OAA2B,IAAV5J,EAEvB,IAAI6J,EAAQxC,EAAKxH,GACjB,MAAQgK,GAAS5C,EAAI0C,GACnB9J,GAAO4B,IAAOwF,GACd4C,EAAQxC,EAAKxH,GAGf,GAAKgK,EAkCE,IAAI5C,IAAM0C,EAaf,OADKE,EAAML,IAAWI,IAASC,EAAML,GAAS,CAAC,GACxCE,EAAMjI,EAAKK,QAAQmF,GAAIjH,EAAO6J,EAAML,IAX3C,GAAII,EAEF,YAAgC,IAAlBC,EAAMJ,GAChBI,EAAML,GACNK,EAAMJ,GAGZI,EAAMJ,GAAUzJ,CAKlB,MAtBE,GAxBe2F,EAAMwD,IAAI1B,IAAIJ,GAAM,CAACyC,EAAUC,KAC5C,IAAIC,EAAI,EACJC,EAAc,GAClB,KAAOF,EAAOC,KAAOvI,EAAKuI,IACxBC,GAAeF,EAAOC,KAExB,GAAIC,EAAa,CACf,GAAIL,EAAS,CAEX,GAAII,GAAKL,EAAK,OAGd,OADAjB,EAAIqB,EAAOjI,MAAMkI,IAAMF,EAChBA,CACT,CAEA,IAAII,EAAU,CACZ,CAACH,EAAOjI,MAAMkI,IAAKF,EACnB,CAACrI,EAAKK,MAAMkI,IAAK,CAAC,CAACP,GAASzJ,IAI9B,OAFAqH,EAAK4C,GAAe,CAAC,CAACT,GAAQU,UACvB7C,EAAK0C,IACL,CACT,MAOK,GAAIH,EACT,OAAOlB,MANI,CACX,GAAIkB,EAAS,OAERvC,EAAKxH,KAAMwH,EAAKxH,GAAO,CAAC,GAC7BwH,EAAKxH,GAAK4J,GAAUzJ,CACtB,CAiBF,EAEF,OAAO0J,GAGThE,EAAM+B,IAAM,SAASA,EAAIiC,EAAO3F,EAAIT,EAAK0E,GAClCA,IAAKA,EAAM,IAChB,IAAIX,EAAOqC,EAAMF,IAAUE,EACvBjI,EAAOxD,OAAOwD,KAAK4F,GAAM8C,OAG7B,IAAK,IAAIlD,EAAI,EAAGA,EAAIxF,EAAK0G,OAAQlB,IAAK,CACpC,IAAIpH,EAAM4B,EAAKwF,GACX4C,EAAQxC,EAAKxH,GACb6I,EAAMmB,EAAMJ,GAChB,QAAmB,IAARf,GAET,GADAA,EAAM3E,EAAG2E,EAAKV,EAAIY,KAAK,IAAM/I,EAAKA,EAAKmI,QACpB,IAARU,EAAqB,OAAOA,OAC9BpF,GACTS,OAVAiC,EAUMgC,EAAIY,KAAK,IAAK/I,EAAKmI,GAE3B,GAAI6B,EAAML,GAAQ,CAGhB,GAFAxB,EAAIrB,KAAK9G,GACT6I,EAAMjB,EAAIoC,EAAML,GAAQzF,EAAIT,EAAK0E,QACd,IAARU,EAAqB,OAAOA,EACvCV,EAAIoC,KACN,CACF,CACF,EAEA7K,EAAOC,QAAUkG,C,gBCzGjB,MAAMvC,EAAQ,EAAQ,KAChB4C,EAAS,EAAQ,KACjBL,EAAQ,EAAQ,IAChBC,EAAQ,EAAQ,KAyHtBpG,EAAOC,QArEO8D,IACPqC,EAAMwD,IAAIF,GAAG3F,KAAMA,EAAM,CAAC,GAC/BA,EAAIgE,KAAOzB,OAAOvC,EAAIgE,MAAQ,UACzBhE,EAAIpC,QAAOoC,EAAIpC,MArDHmJ,KACjB,GAAIlH,EAAM9D,OAAQ,CAChB,MAAMiL,EAAK,EAAQ,KAGnB,OAFKA,EAAGC,WAAWF,IAAMC,EAAGE,UAAUH,GAE/B,CACLvL,IAAK,CAACwI,EAAMvD,KACVuG,EAAGG,SAASJ,EAAM,IAAM/C,GAAM,CAAC1D,EAAKI,KAClC,GAAIJ,EAAK,CACP,GAAiB,WAAbA,EAAIwC,KAEN,YADArC,IAIFc,QAAQI,IAAI,SAAUrB,EACxB,CACII,IAAMA,EAAOA,EAAKnC,YACtBkC,EAAGH,EAAKI,EAAI,GACb,EAEHL,IAAK,CAAC2D,EAAMtD,EAAMD,KAChB,IAAIpC,EAASC,KAAKD,SAASE,SAAS,IAAIC,OAAO,GAE3C4G,EAAMpB,EAAO,IAAM3F,EAAS,OAChC2I,EAAGI,UAAUhC,EAAK1E,GAAM,CAACJ,EAAKC,KACxBD,EACFG,EAAGH,GAIL0G,EAAGK,OAAOjC,EAAK2B,EAAM,IAAM/C,EAAMvD,EAAE,GACpC,EAEHsC,KAAMtC,IACJuG,EAAGM,QAAQP,GAAK,CAACzG,EAAKyG,KACpBA,EAAI3I,QAAQqC,GACZA,GAAG,GACJ,EAGP,CAGA,MAAO,CACLjF,IAAK,CAACwI,EAAMvD,IAAOA,IACnBJ,IAAK,CAAC2D,EAAMtD,EAAMD,IAAOA,IACzBsC,KAAMtC,GAAMA,IACd,EAM4B8G,CAAWvH,EAAIgE,OAC3C,MAAMhB,EAASP,EAAOzC,GAEtB,MAAO,CACLxE,IAAK,CAACiD,EAAKgC,KACT,IAAKhC,EAEH,YADAgC,EAAG,gBAIL,IAEI1D,EAFA4B,EAAOF,EAAI,KACXlC,EAAMkC,EAAI,MAAQ,GAEtB,MAAM+F,EAAO,CAAC9H,EAAOH,KACnB,IAAImE,EAAOvB,KAAKsC,MAAM/E,GACjBK,IAAMA,EAAO,CAAC6B,EAAG,CAAC,IAAKD,EAAM,IAAK,CAAC,KACxC5B,EAAKR,GAAOmE,EAAK,GACjB3D,EAAK6B,EAAE,KAAKrC,GAAOmE,EAAK,EAAC,EAG3BsC,EAAOrE,EAAO,IAAMpC,GAAK,CAAC+D,EAAK5D,KAC7B,IAAIgC,EACAhC,IACF0F,EAAM+B,IAAIzH,EAAO8H,GACZzH,GAAMyH,EAAK9H,EAAOH,GACvBmC,EAAQ,CAAC,CAACC,GAAO5B,IAEnB0D,EAAGH,EAAK5B,EAAK,GACd,EAEH2B,IAAK,CAAC3B,EAAO+B,KACX,IAAK/B,EAEH,YADA+B,EAAG,kBAIL,IAAI8D,EAAQ,EACZ,MAAMnE,EAAM,CAACE,EAAKC,KAChBgE,IACInE,EAAIE,OAEHF,EAAIE,IAAMA,GACbG,EAAGH,GAAO,UAIRiE,EAAQ,GAEZ9D,EAAGL,EAAIE,IAAK,GAAC,EAGf3F,OAAOwD,KAAKO,GAAON,SAAQO,IACzB,IAAI5B,EAAO2B,EAAMC,GACjBhE,OAAOwD,KAAKpB,GAAMqB,SAAQ7B,IACxB,GAAI,MAAQA,EAAK,OAEjBgI,IACA,IAAI7H,EAAQK,EAAKR,GACbuC,EAAQ/B,EAAK6B,EAAE,KAAKrC,GACxByG,EAAOrE,EAAO,IAAMpC,EAAK4C,KAAKC,UAAU,CAAC1C,EAAOoC,IAASsB,EAAG,GAC7D,GACF,EAEL,C,UCzHF,MAAMwF,EAAM,CACVD,GAAIG,KACAA,aAAa0B,SACd1B,EAAIG,WAAWH,GAAK,GAAK,GAAK2B,MAAa3B,IAAK,MAAcA,IAG7DD,EAAM,CACVF,GAAIE,KACGA,IAGFA,aAAelL,QAAUkL,EAAI5I,cAAgBtC,QAE5C,WADFA,OAAOO,UAAUqD,SAAS/B,KAAKqJ,GAAK6B,MAAM,sBAAsB,IAIpEvD,IAAK,CAACpB,EAAMtC,EAAIoF,KACd,IAAI1H,EAAOxD,OAAOwD,KAAK4E,GACvB,IAAK,IAAIY,EAAI,EAAGA,EAAIxF,EAAK0G,OAAQlB,IAAK,CACpC,IAAIgE,EAASlH,EAAGsC,EAAK5E,EAAKwF,IAAKxF,EAAKwF,GAAIkC,GACxC,QAAsB,IAAX8B,EAAwB,OAAOA,CAC5C,GAEFtH,IAAK,CAACwF,EAAKtJ,EAAKG,KACTmJ,IAAKA,EAAM,CAAC,GACjBA,EAAItJ,GAAOG,EACJmJ,GAET+B,IAAK,CAAC/B,EAAKtJ,KACT,GAAKsJ,EAIL,OAFAA,EAAItJ,GAAO,YACJsJ,EAAItJ,GACJsJ,IAILgC,EAAW,CAAClJ,EAAMpC,EAAKsJ,KAGvBA,EAAIhI,GACNgI,EAAIhI,IAAK,EAWXgI,EAAIhI,GAPQ,MAARtB,GAA+B,iBAAToC,GACfA,CAMF,EAIL+G,EAAM,CACVC,GAAIjJ,IACF,GAAIA,GAASA,EAAM,OAASA,EAAMkC,GAAKkJ,OAAOpL,GAAQ,CACpD,IAAImJ,EAAM,CAAC,EAEX,GADAA,EAAI1B,IAAIzH,EAAOmL,EAAUhC,GACrBA,EAAIhI,GAAI,OAAO2H,EAAE3H,EACvB,CAEA,OAAO,GAGTmI,IAAKrH,GAAQkH,EAAIxF,IAAI,CAAC,EAAG,IAAK1B,IAGhC1C,EAAOC,QAAU,CAAC0J,MAAKC,MAAKH,M,cCrExBqC,EAA2B,CAAC,ECE5BC,EDCJ,SAASC,EAAoBC,GAE5B,IAAIC,EAAeJ,EAAyBG,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAajM,QAGrB,IAAID,EAAS8L,EAAyBG,GAAY,CAGjDhM,QAAS,CAAC,GAOX,OAHAmM,EAAoBH,GAAUjM,EAAQA,EAAOC,QAAS+L,GAG/ChM,EAAOC,OACf,CCnB0B+L,CAAoB,K","sources":["webpack://Holster/./node_modules/browser-or-node/dist/index.js","webpack://Holster/./node_modules/ws/browser.js","webpack://Holster/./src/dup.js","webpack://Holster/./src/get.js","webpack://Holster/./src/ham.js","webpack://Holster/./src/holster.js","webpack://Holster/./src/radisk.js","webpack://Holster/./src/radix.js","webpack://Holster/./src/store.js","webpack://Holster/./src/utils.js","webpack://Holster/webpack/bootstrap","webpack://Holster/webpack/startup"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  isBrowser: () => isBrowser,\n  isBun: () => isBun,\n  isDeno: () => isDeno,\n  isJsDom: () => isJsDom,\n  isNode: () => isNode,\n  isWebWorker: () => isWebWorker\n});\nmodule.exports = __toCommonJS(src_exports);\nvar isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\nvar isNode = (\n  // @ts-expect-error\n  typeof process !== \"undefined\" && // @ts-expect-error\n  process.versions != null && // @ts-expect-error\n  process.versions.node != null\n);\nvar isWebWorker = typeof self === \"object\" && self.constructor && self.constructor.name === \"DedicatedWorkerGlobalScope\";\nvar isJsDom = typeof window !== \"undefined\" && window.name === \"nodejs\" || typeof navigator !== \"undefined\" && \"userAgent\" in navigator && typeof navigator.userAgent === \"string\" && (navigator.userAgent.includes(\"Node.js\") || navigator.userAgent.includes(\"jsdom\"));\nvar isDeno = (\n  // @ts-expect-error\n  typeof Deno !== \"undefined\" && // @ts-expect-error\n  typeof Deno.version !== \"undefined\" && // @ts-expect-error\n  typeof Deno.version.deno !== \"undefined\"\n);\nvar isBun = typeof process !== \"undefined\" && process.versions != null && process.versions.bun != null;\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  isBrowser,\n  isBun,\n  isDeno,\n  isJsDom,\n  isNode,\n  isWebWorker\n});\n","'use strict';\n\nmodule.exports = function () {\n  throw new Error(\n    'ws does not work in the browser. Browser clients must use the native ' +\n      'WebSocket object'\n  );\n};\n","const Dup = () => {\n  const maxAge = 9000\n  const dup = {store: {}}\n  dup.check = id => (dup.store[id] ? dup.track(id) : false)\n  dup.track = id => {\n    // Keep the liveliness of the message up while it is being received.\n    dup.store[id] = Date.now()\n    if (!dup.expiry) {\n      dup.expiry = setTimeout(() => {\n        const now = Date.now()\n        Object.keys(dup.store).forEach(id => {\n          if (now - dup.store[id] > maxAge) delete dup.store[id]\n        })\n        dup.expiry = null\n      }, maxAge)\n    }\n    return id\n  }\n  return dup\n}\n\nDup.random = () => {\n  return Math.random().toString(36).slice(-9)\n}\n\nmodule.exports = Dup\n","const Get = (lex, graph) => {\n  const soul = lex[\"#\"]\n  const key = lex[\".\"]\n  var node = graph[soul]\n\n  // Can only return a node if a key is provided, because the graph may not\n  // have all the keys populated for a given soul. This is because Ham.mix\n  // only adds incoming changes to the graph.\n  if (!node || !key) return\n\n  let value = node[key]\n  if (!value) return\n\n  node = {_: node._, [key]: value}\n  node._[\">\"] = {[key]: node._[\">\"][key]}\n  return {[soul]: node}\n}\n\nmodule.exports = Get\n","// state and value are the incoming changes.\n// currentState and currentValue are the current graph data.\nconst Ham = (state, currentState, value, currentValue) => {\n  if (state < currentState) {\n    return {historical: true}\n  }\n\n  if (state > currentState) {\n    return {incoming: true}\n  }\n\n  // state is equal to currentState, lexically compare to resolve conflict.\n  value = JSON.stringify(value) || \"\"\n  currentValue = JSON.stringify(currentValue) || \"\"\n  // No update required.\n  if (value === currentValue) {\n    return {state: true}\n  }\n\n  // Keep the current value.\n  if (value < currentValue) {\n    return {current: true}\n  }\n\n  // Otherwise update using the incoming value.\n  return {incoming: true}\n}\n\nHam.mix = (change, graph) => {\n  var machine = Date.now()\n  var update = {}\n  var defer = {}\n  let wait = 0\n\n  Object.keys(change).forEach(soul => {\n    const node = change[soul]\n    Object.keys(node).forEach(key => {\n      if (key === \"_\") return\n\n      const value = node[key]\n      const state = node._[\">\"][key]\n      const currentValue = (graph[soul] || {})[key]\n      const currentState = (graph[soul] || {_: {\">\": {}}})._[\">\"][key] || 0\n\n      // Defer the update if ahead of machine time.\n      const skew = state - machine\n      if (skew > 0) {\n        // Ignore update if ahead by more than 24 hours.\n        if (skew > 86400000) return\n\n        // Wait the shortest difference before trying the updates again.\n        if (wait === 0 || skew < wait) wait = skew\n        if (!defer[soul]) defer[soul] = {_: {\"#\": soul, \">\": {}}}\n        defer[soul][key] = value\n        defer[soul]._[\">\"][key] = state\n      } else {\n        const result = Ham(state, currentState, value, currentValue)\n        if (result.incoming) {\n          if (!update[soul]) update[soul] = {_: {\"#\": soul, \">\": {}}}\n          // TODO: graph should not just grow indefintitely in memory.\n          // Need to have a max size after which start dropping the oldest state\n          // Do something similar to Dup which can handle deletes?\n          if (!graph[soul]) graph[soul] = {_: {\"#\": soul, \">\": {}}}\n          graph[soul][key] = update[soul][key] = value\n          graph[soul]._[\">\"][key] = update[soul]._[\">\"][key] = state\n        }\n      }\n    })\n  })\n  return {now: update, defer: defer, wait: wait}\n}\n\nmodule.exports = Ham\n","const jsEnv = require(\"browser-or-node\")\nconst Dup = require(\"./dup\")\nconst Get = require(\"./get\")\nconst Ham = require(\"./ham\")\nconst Store = require(\"./store\")\n\nconst Holster = opt => {\n  const dup = Dup()\n  const store = Store(opt)\n  var graph = {}\n  var queue = {}\n\n  const get = (msg, send) => {\n    const ack = Get(msg.get, graph)\n    if (ack) {\n      send(\n        JSON.stringify({\n          \"#\": dup.track(Dup.random()),\n          \"@\": msg[\"#\"],\n          put: ack,\n        }),\n      )\n    } else {\n      store.get(msg.get, (err, ack) => {\n        send(\n          JSON.stringify({\n            \"#\": dup.track(Dup.random()),\n            \"@\": msg[\"#\"],\n            put: ack,\n            err: err,\n          }),\n        )\n      })\n    }\n  }\n\n  const put = (msg, send) => {\n    // Store updates returned from Ham.mix and defer updates if required.\n    const update = Ham.mix(msg.put, graph)\n    store.put(update.now, (err, ok) => {\n      send(\n        JSON.stringify({\n          \"#\": dup.track(Dup.random()),\n          \"@\": msg[\"#\"],\n          err: err,\n          ok: ok,\n        }),\n      )\n    })\n    if (update.wait !== 0) {\n      setTimeout(() => put(update.defer, send), update.wait)\n    }\n  }\n\n  const api = send => {\n    return {\n      get: (lex, cb) => {\n        const ack = Get(lex, graph)\n        if (ack) {\n          cb(null, ack)\n          return\n        }\n\n        store.get(lex, (err, ack) => {\n          if (ack) {\n            cb(null, ack)\n            return\n          }\n\n          const track = Dup.random()\n          queue[track] = cb\n          send(\n            JSON.stringify({\n              \"#\": dup.track(track),\n              get: lex,\n            }),\n          )\n        })\n      },\n      put: (data, cb) => {\n        // Deferred updates are only stored using wire spec, they're ignored\n        // here using the api. This is ok because correct timestamps should be\n        // used whereas wire spec needs to handle clock skew.\n        const update = Ham.mix(data, graph)\n        store.put(update.now, cb)\n        // Also put data on the wire spec.\n        // TODO: Note that this means all clients now receive all updates, so\n        // need to filter what should be stored, both in graph and on disk.\n        send(\n          JSON.stringify({\n            \"#\": dup.track(Dup.random()),\n            put: data,\n          }),\n        )\n      },\n    }\n  }\n\n  if (jsEnv.isNode) {\n    const WebSocket = require(\"ws\")\n    const wss = new WebSocket.Server({port: 8080})\n    const send = (data, isBinary) => {\n      wss.clients.forEach(client => {\n        if (client.readyState === WebSocket.OPEN) {\n          client.send(data, {binary: isBinary})\n        }\n      })\n    }\n    wss.on(\"connection\", ws => {\n      ws.on(\"error\", console.error)\n\n      ws.on(\"message\", (data, isBinary) => {\n        const msg = JSON.parse(data)\n        if (dup.check(msg[\"#\"])) return\n\n        dup.track(msg[\"#\"])\n        if (msg.get) get(msg, send)\n        if (msg.put) put(msg, send)\n        send(data, isBinary)\n        if ((cb = queue[msg[\"@\"]])) {\n          cb(null, msg)\n          delete queue[msg[\"@\"]]\n        }\n      })\n    })\n    return api(send)\n  }\n\n  let ws = new WebSocket(\"ws://localhost:8080\")\n  const send = data => {\n    if (!ws || ws.readyState !== WebSocket.OPEN) {\n      console.log(\"websocket not available\")\n      return\n    }\n\n    ws.send(data)\n  }\n  const start = () => {\n    if (!ws) ws = new WebSocket(\"ws://localhost:8080\")\n    ws.onclose = c => {\n      ws = null\n      setTimeout(start, Math.floor(Math.random() * 5000))\n    }\n    ws.onerror = e => {\n      console.error(e)\n    }\n    ws.onmessage = m => {\n      const msg = JSON.parse(m.data)\n      if (dup.check(msg[\"#\"])) return\n\n      dup.track(msg[\"#\"])\n      if (msg.get) get(msg, send)\n      if (msg.put) put(msg, send)\n      if ((cb = queue[msg[\"@\"]])) {\n        cb(null, msg)\n        delete queue[msg[\"@\"]]\n      }\n      send(m.data)\n    }\n  }\n\n  start()\n  return api(send)\n}\n\nmodule.exports = Holster\n","const Radix = require(\"./radix\")\nconst utils = require(\"./utils\")\n\n// ASCII character for unit separator.\nconst unit = String.fromCharCode(31)\n\nconst Radisk = opt => {\n  var u\n  var cache = null\n\n  if (!opt) opt = {}\n  if (!opt.log) opt.log = console.log\n  if (!opt.batch) opt.batch = 10 * 1000\n  if (!opt.wait) opt.wait = 1\n  if (!opt.size) opt.size = 1024 * 1024 // 1MB\n  if (!opt.code) opt.code = \"!\" // The first printable character\n  if (!opt.store) {\n    opt.log(\n      \"Radisk needs `store` interface with `{get: fn, put: fn, list: fn}`\",\n    )\n    return\n  }\n  if (!opt.store.get) {\n    opt.log(\"Radisk needs `store.get` interface with `(file, cb)`\")\n    return\n  }\n  if (!opt.store.put) {\n    opt.log(\"Radisk needs `store.put` interface with `(file, data, cb)`\")\n    return\n  }\n  if (!opt.store.list) {\n    opt.log(\"Radisk needs a streaming `store.list` interface with `(cb)`\")\n    return\n  }\n\n  /*\n\t\tAny and all storage adapters should...\n\t\t1. Because writing to disk takes time, we should batch data to disk.\n       This improves performance, and reduces potential disk corruption.\n\t\t2. If a batch exceeds a certain number of writes, we should immediately\n       write to disk when physically possible. This caps total performance,\n       but reduces potential loss.\n\t*/\n  const radisk = (key, value, cb) => {\n    key = \"\" + key\n\n    // If no value is provided then the second parameter is the callback\n    // function. Read value from memory or disk and call callback with it.\n    if (typeof value === \"function\") {\n      cb = value\n      value = radisk.batch(key)\n      if (typeof value !== \"undefined\") {\n        return cb(u, value)\n      }\n\n      if (radisk.thrash.at) {\n        value = radisk.thrash.at(key)\n        if (typeof value !== \"undefined\") {\n          return cb(u, value)\n        }\n      }\n\n      return radisk.read(key, cb)\n    }\n\n    // Otherwise store the value provided.\n    radisk.batch(key, value)\n    if (cb) {\n      radisk.batch.acks.push(cb)\n    }\n    // Don't wait if we have batched too many.\n    if (++radisk.batch.ed >= opt.batch) {\n      return radisk.thrash()\n    }\n\n    // Otherwise wait for more updates before writing.\n    clearTimeout(radisk.batch.timeout)\n    radisk.batch.timeout = setTimeout(radisk.thrash, opt.wait)\n  }\n\n  radisk.batch = Radix()\n  radisk.batch.acks = []\n  radisk.batch.ed = 0\n\n  radisk.thrash = () => {\n    if (radisk.thrash.ing) {\n      return (radisk.thrash.more = true)\n    }\n\n    clearTimeout(radisk.batch.timeout)\n    radisk.thrash.more = false\n    radisk.thrash.ing = true\n    var batch = (radisk.thrash.at = radisk.batch)\n    radisk.batch = null\n    radisk.batch = Radix()\n    radisk.batch.acks = []\n    radisk.batch.ed = 0\n    let i = 0\n    radisk.save(batch, (err, ok) => {\n      // This is to ignore multiple callbacks from radisk.save calling\n      // radisk.write? It looks like multiple callbacks will be made if a\n      // file needs to be split.\n      if (++i > 1) return\n\n      if (err) opt.log(err)\n      batch.acks.forEach(cb => cb(err, ok))\n      radisk.thrash.at = null\n      radisk.thrash.ing = false\n      if (radisk.thrash.more) radisk.thrash()\n    })\n  }\n\n  /*\n\t\t1. Find the first radix item in memory\n\t\t2. Use that as the starting index in the directory of files\n\t\t3. Find the first file that is lexically larger than it\n\t\t4. Read the previous file into memory\n\t\t5. Scan through in memory radix for all values lexically less than the limit\n\t\t6. Merge and write all of those to the in-memory file and back to disk\n\t\t7. If file is to large then split. More details needed here\n\t*/\n  radisk.save = (rad, cb) => {\n    const save = {\n      find: (tree, key) => {\n        // This is false for any key until save.start is set to an initial key.\n        if (key < save.start) return\n\n        save.start = key\n        opt.store.list(save.lex)\n        return true\n      },\n      lex: file => {\n        if (!file || file > save.start) {\n          save.end = file\n          save.mix(save.file || opt.code, save.start, save.end)\n          return true\n        }\n\n        save.file = file\n      },\n      mix: (file, start, end) => {\n        save.start = save.end = save.file = u\n        radisk.parse(file, (err, disk) => {\n          if (err) return cb(err)\n\n          Radix.map(rad, (value, key) => {\n            if (key < start) return\n\n            if (end && end < key) {\n              save.start = key\n              return save.start\n            }\n\n            disk(key, value)\n          })\n          radisk.write(file, disk, save.next)\n        })\n      },\n      next: (err, ok) => {\n        if (err) return cb(err)\n\n        if (save.start) return Radix.map(rad, save.find)\n\n        cb(err, ok)\n      },\n    }\n    Radix.map(rad, save.find)\n  }\n\n  /*\n\t\tAny storage engine at some point will have to do a read in order to write.\n\t\tThis is true of even systems that use an append only log, if they support\n    updates. Therefore it is unavoidable that a read will have to happen, the\n\t\tquestion is just how long you delay it.\n\t*/\n  radisk.write = (file, rad, cb) => {\n    // Invalidate cache on write.\n    cache = null\n    const write = {\n      text: \"\",\n      count: 0,\n      file: file,\n      each: (value, key, k, pre) => {\n        write.count++\n        var enc =\n          Radisk.encode(pre.length) +\n          \"#\" +\n          Radisk.encode(k) +\n          (typeof value === \"undefined\" ? \"\" : \"=\" + Radisk.encode(value)) +\n          \"\\n\"\n        // Cannot split the file if only have one entry to write.\n        if (write.count > 1 && write.text.length + enc.length > opt.size) {\n          write.text = \"\"\n          // Otherwise split the entries in half.\n          write.limit = Math.ceil(write.count / 2)\n          write.count = 0\n          write.sub = Radix()\n          Radix.map(rad, write.slice)\n          return true\n        }\n\n        write.text += enc\n      },\n      put: () => {\n        opt.store.put(file, write.text, cb)\n      },\n      slice: (value, key) => {\n        if (key < write.file) return\n\n        if (++write.count > write.limit) {\n          var name = write.file\n          // Use only the soul of the key as the filename so that all\n          // properties of a soul are written to the same file.\n          let end = key.indexOf(\".\")\n          if (end === -1) {\n            write.file = key\n          } else {\n            write.file = key.substring(0, end)\n          }\n          write.count = 0\n          radisk.write(name, write.sub, write.next)\n          return true\n        }\n\n        write.sub(key, value)\n      },\n      next: err => {\n        if (err) return cb(err)\n\n        write.sub = Radix()\n        if (!Radix.map(rad, write.slice)) {\n          radisk.write(write.file, write.sub, cb)\n        }\n      },\n    }\n    // If Radix.map doesn't return true when called with write.each as a\n    // callback then didn't need to split the data. The accumulated write.text\n    // can then be stored with write.put().\n    if (!Radix.map(rad, write.each, true)) write.put()\n  }\n\n  radisk.read = (key, cb) => {\n    if (cache) {\n      let value = cache(key)\n      if (typeof value !== \"undefined\") return cb(u, value)\n    }\n\n    const read = {\n      lex: file => {\n        // store.list should call lex without a file last, which means no\n        // file was found that was greater than key. That means the current\n        // read.file is the right place to read the key.\n        if (!file || file > key) {\n          if (!read.file) {\n            cb(\"no file found\", u)\n            return\n          }\n\n          if (read.ing) return\n\n          read.ing = true\n          radisk.parse(read.file, read.it)\n          return\n        }\n\n        read.file = file\n      },\n      it: (err, disk) => {\n        if (err) opt.log(err)\n        if (disk) {\n          cache = disk\n          read.value = disk(key)\n        }\n        cb(err, read.value)\n      },\n    }\n    opt.store.list(read.lex)\n  }\n\n  /*\n\t\tLet us start by assuming we are the only process that is\n\t\tchanging the directory or bucket. Not because we do not want\n\t\tto be multi-process/machine, but because we want to experiment\n\t\twith how much performance and scale we can get out of only one.\n\t\tThen we can work on the harder problem of being multi-process.\n\t*/\n  radisk.parse = (file, cb) => {\n    const parse = {\n      disk: Radix(),\n      read: (err, data) => {\n        if (err) return cb(err)\n\n        if (!data) return cb(u, parse.disk)\n\n        let pre = []\n        let tmp = parse.split(data)\n        while (tmp) {\n          let key\n          let value\n          let i = tmp[1]\n          tmp = parse.split(tmp[2]) || \"\"\n          if (tmp[0] === \"#\") {\n            key = tmp[1]\n            pre = pre.slice(0, i)\n            if (i <= pre.length) pre.push(key)\n          }\n          tmp = parse.split(tmp[2]) || \"\"\n          if (tmp[0] === \"\\n\") continue\n\n          if (tmp[0] === \"=\") value = tmp[1]\n          if (typeof key !== \"undefined\" && typeof value !== \"undefined\") {\n            parse.disk(pre.join(\"\"), value)\n          }\n          tmp = parse.split(tmp[2])\n        }\n        cb(u, parse.disk)\n      },\n      split: data => {\n        if (!data) return\n\n        let i = -1\n        let a = \"\"\n        let c = null\n        while ((c = data[++i])) {\n          if (c === unit) break\n\n          a += c\n        }\n        let o = {}\n        if (c) {\n          return [a, Radisk.decode(data.slice(i), o), data.slice(i + o.i)]\n        }\n      },\n    }\n    opt.store.get(file, parse.read)\n  }\n\n  return radisk\n}\n\nRadisk.encode = data => {\n  if (typeof data == \"string\") {\n    let i = 0\n    let current = null\n    let text = unit\n    while ((current = data[i++])) {\n      if (current === unit) text += unit\n    }\n    return text + '\"' + data + unit\n  }\n\n  let tmp = null\n  if (data && data[\"#\"] && (tmp = utils.rel.is(data)))\n    return unit + \"#\" + tmp + unit\n\n  if (utils.num.is(data)) return unit + \"+\" + (data || 0) + unit\n\n  if (data === null) return unit + \" \" + unit\n\n  if (data === true) return unit + \"+\" + unit\n\n  if (data === false) return unit + \"-\" + unit\n}\n\nRadisk.decode = (data, obj) => {\n  var text = \"\"\n  var i = -1\n  var n = 0\n  var current = null\n  var previous = null\n  if (data[0] !== unit) return\n\n  // Find a control character previous to the text we want, skipping\n  // consecutive unit separator characters at the beginning of the data.\n  while ((current = data[++i])) {\n    if (previous) {\n      if (current === unit) {\n        if (--n <= 0) break\n      }\n      text += current\n    } else if (current === unit) {\n      n++\n    } else {\n      previous = current || true\n    }\n  }\n\n  if (obj) obj.i = i + 1\n\n  if (previous === '\"') return text\n\n  if (previous === \"#\") return utils.rel.ify(text)\n\n  if (previous === \"+\") {\n    if (text.length === 0) return true\n\n    return parseFloat(text)\n  }\n\n  if (previous === \" \") return null\n\n  if (previous === \"-\") return false\n}\n\nmodule.exports = Radisk\n","const utils = require(\"./utils\")\n\n// ASCII character for group separator.\nconst group = String.fromCharCode(29)\n// ASCII character for record separator.\nconst record = String.fromCharCode(30)\n\nconst Radix = () => {\n  const radix = (keys, value, tree) => {\n    if (!tree) {\n      if (!radix[group]) radix[group] = {}\n      tree = radix[group]\n    }\n    if (!keys) return tree\n\n    let i = 0\n    let tmp = {}\n    let key = keys[i]\n    const max = keys.length - 1\n    const noValue = typeof value === \"undefined\"\n    // Find a matching value using the shortest string from keys.\n    let found = tree[key]\n    while (!found && i < max) {\n      key += keys[++i]\n      found = tree[key]\n    }\n\n    if (!found) {\n      // If not found from the provided keys try matching with an existing key.\n      const result = utils.obj.map(tree, (hasValue, hasKey) => {\n        let j = 0\n        let matchingKey = \"\"\n        while (hasKey[j] === keys[j]) {\n          matchingKey += hasKey[j++]\n        }\n        if (matchingKey) {\n          if (noValue) {\n            // matchingKey has to be as long as the original keys when reading.\n            if (j <= max) return\n\n            tmp[hasKey.slice(j)] = hasValue\n            return hasValue\n          }\n\n          let replace = {\n            [hasKey.slice(j)]: hasValue,\n            [keys.slice(j)]: {[record]: value},\n          }\n          tree[matchingKey] = {[group]: replace}\n          delete tree[hasKey]\n          return true\n        }\n      })\n      if (!result) {\n        if (noValue) return\n\n        if (!tree[key]) tree[key] = {}\n        tree[key][record] = value\n      } else if (noValue) {\n        return tmp\n      }\n    } else if (i === max) {\n      // If no value use the key provided to return a whole group or record.\n      if (noValue) {\n        // If an individual record isn't found then return the whole group.\n        return typeof found[record] === \"undefined\"\n          ? found[group]\n          : found[record]\n      }\n      // Otherwise create a new record at the provided key for value.\n      found[record] = value\n    } else {\n      // Found at a shorter key, try again.\n      if (!found[group] && !noValue) found[group] = {}\n      return radix(keys.slice(++i), value, found[group])\n    }\n  }\n  return radix\n}\n\nRadix.map = function map(radix, cb, opt, pre) {\n  if (!pre) pre = []\n  var tree = radix[group] || radix\n  var keys = Object.keys(tree).sort()\n  var u\n\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i]\n    let found = tree[key]\n    let tmp = found[record]\n    if (typeof tmp !== \"undefined\") {\n      tmp = cb(tmp, pre.join(\"\") + key, key, pre)\n      if (typeof tmp !== \"undefined\") return tmp\n    } else if (opt) {\n      cb(u, pre.join(\"\"), key, pre)\n    }\n    if (found[group]) {\n      pre.push(key)\n      tmp = map(found[group], cb, opt, pre)\n      if (typeof tmp !== \"undefined\") return tmp\n      pre.pop()\n    }\n  }\n}\n\nmodule.exports = Radix\n","const jsEnv = require(\"browser-or-node\")\nconst Radisk = require(\"./radisk\")\nconst Radix = require(\"./radix\")\nconst utils = require(\"./utils\")\n\nconst fileSystem = dir => {\n  if (jsEnv.isNode) {\n    const fs = require(\"fs\")\n    if (!fs.existsSync(dir)) fs.mkdirSync(dir)\n\n    return {\n      get: (file, cb) => {\n        fs.readFile(dir + \"/\" + file, (err, data) => {\n          if (err) {\n            if (err.code === \"ENOENT\") {\n              cb()\n              return\n            }\n\n            console.log(\"ERROR:\", err)\n          }\n          if (data) data = data.toString()\n          cb(err, data)\n        })\n      },\n      put: (file, data, cb) => {\n        var random = Math.random().toString(36).slice(-9)\n        // Don't put tmp files under dir so that they're not listed.\n        var tmp = file + \".\" + random + \".tmp\"\n        fs.writeFile(tmp, data, (err, ok) => {\n          if (err) {\n            cb(err)\n            return\n          }\n\n          fs.rename(tmp, dir + \"/\" + file, cb)\n        })\n      },\n      list: cb => {\n        fs.readdir(dir, (err, dir) => {\n          dir.forEach(cb)\n          cb()\n        })\n      },\n    }\n  }\n\n  // TODO: Add indexedDB\n  return {\n    get: (file, cb) => cb(),\n    put: (file, data, cb) => cb(),\n    list: cb => cb(),\n  }\n}\n\nconst Store = opt => {\n  if (!utils.obj.is(opt)) opt = {}\n  opt.file = String(opt.file || \"radata\")\n  if (!opt.store) opt.store = fileSystem(opt.file)\n  const radisk = Radisk(opt)\n\n  return {\n    get: (lex, cb) => {\n      if (!lex) {\n        cb(\"lex required\")\n        return\n      }\n\n      var soul = lex[\"#\"]\n      var key = lex[\".\"] || \"\"\n      var node\n      const each = (value, key) => {\n        var data = JSON.parse(value)\n        if (!node) node = {_: {\"#\": soul, \">\": {}}}\n        node[key] = data[0]\n        node._[\">\"][key] = data[1]\n      }\n\n      radisk(soul + \".\" + key, (err, value) => {\n        let graph\n        if (value) {\n          Radix.map(value, each)\n          if (!node) each(value, key)\n          graph = {[soul]: node}\n        }\n        cb(err, graph)\n      })\n    },\n    put: (graph, cb) => {\n      if (!graph) {\n        cb(\"graph required\")\n        return\n      }\n\n      var count = 0\n      const ack = (err, ok) => {\n        count--\n        if (ack.err) return\n\n        if ((ack.err = err)) {\n          cb(err || \"ERROR!\")\n          return\n        }\n\n        if (count > 0) return\n\n        cb(ack.err, 1)\n      }\n\n      Object.keys(graph).forEach(soul => {\n        var node = graph[soul]\n        Object.keys(node).forEach(key => {\n          if (\"_\" === key) return\n\n          count++\n          let value = node[key]\n          let state = node._[\">\"][key]\n          radisk(soul + \".\" + key, JSON.stringify([value, state]), ack)\n        })\n      })\n    },\n  }\n}\n\nmodule.exports = Store\n","const num = {\n  is: n =>\n    !(n instanceof Array) &&\n    (n - parseFloat(n) + 1 >= 0 || Infinity === n || -Infinity === n),\n}\n\nconst obj = {\n  is: obj => {\n    if (!obj) return false\n\n    return (\n      (obj instanceof Object && obj.constructor === Object) ||\n      Object.prototype.toString.call(obj).match(/^\\[object (\\w+)\\]$/)[1] ===\n        \"Object\"\n    )\n  },\n  map: (list, cb, obj) => {\n    var keys = Object.keys(list)\n    for (let i = 0; i < keys.length; i++) {\n      let result = cb(list[keys[i]], keys[i], obj)\n      if (typeof result !== \"undefined\") return result\n    }\n  },\n  put: (obj, key, value) => {\n    if (!obj) obj = {}\n    obj[key] = value\n    return obj\n  },\n  del: (obj, key) => {\n    if (!obj) return\n\n    obj[key] = null\n    delete obj[key]\n    return obj\n  },\n}\n\nconst map_soul = (soul, key, obj) => {\n  // If id is already defined AND we're still looping through the object,\n  // then it is considered invalid.\n  if (obj.id) {\n    obj.id = false\n    return\n  }\n\n  if (key === \"#\" && typeof soul === \"string\") {\n    obj.id = soul\n    return\n  }\n\n  // If there exists anything else on the object that isn't the soul,\n  // then it is considered invalid.\n  obj.id = false\n}\n\n// Check if an object is a soul relation, ie {'#': 'UUID'}\nconst rel = {\n  is: value => {\n    if (value && value[\"#\"] && !value._ && obj_is(value)) {\n      let obj = {}\n      obj.map(value, map_soul, obj)\n      if (obj.id) return o.id\n    }\n\n    return false\n  },\n  // Convert a soul into a relation and return it.\n  ify: soul => obj.put({}, \"#\", soul),\n}\n\nmodule.exports = {num, obj, rel}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(299);\n"],"names":["mod","__defProp","Object","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__hasOwnProp","prototype","hasOwnProperty","src_exports","target","all","name","get","enumerable","__export","isBrowser","isBun","isDeno","isJsDom","isNode","isWebWorker","module","exports","to","from","except","desc","key","call","__copyProps","value","window","document","process","versions","node","self","constructor","navigator","userAgent","includes","Deno","version","deno","bun","Error","Dup","dup","store","id","track","Date","now","expiry","setTimeout","keys","forEach","random","Math","toString","slice","lex","graph","soul","_","Ham","state","currentState","currentValue","historical","incoming","JSON","stringify","current","mix","change","machine","update","defer","wait","skew","jsEnv","Get","Store","opt","queue","msg","send","ack","put","err","ok","api","cb","data","WebSocket","wss","Server","port","isBinary","clients","client","readyState","OPEN","binary","on","ws","console","error","parse","check","log","start","onclose","c","floor","onerror","e","onmessage","m","Radix","utils","unit","String","fromCharCode","Radisk","u","cache","batch","size","code","list","radisk","thrash","at","read","acks","push","ed","clearTimeout","timeout","ing","more","i","save","rad","find","tree","file","end","disk","map","write","next","text","count","each","k","pre","enc","encode","length","limit","ceil","sub","indexOf","substring","it","tmp","split","join","a","o","decode","rel","is","num","obj","n","previous","ify","parseFloat","group","record","radix","max","noValue","found","hasValue","hasKey","j","matchingKey","replace","sort","pop","dir","fs","existsSync","mkdirSync","readFile","writeFile","rename","readdir","fileSystem","Array","Infinity","match","result","del","map_soul","obj_is","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__"],"sourceRoot":""}